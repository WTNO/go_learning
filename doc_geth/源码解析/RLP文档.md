包rlp实现了RLP序列化格式。

RLP（递归线性前缀）的目的是编码任意嵌套的二进制数据数组，RLP是以太坊中用于序列化对象的主要编码方法。RLP的唯一目的是编码结构；编码特定的原子数据类型（例如字符串、整数、浮点数）留给高阶协议处理。在以太坊中，整数必须以大端二进制形式表示，没有前导零（因此将整数值零等同于空字符串）。

RLP值由类型标记区分。类型标记在输入流中位于值之前，并定义了随后的字节的大小和类型。

# 编码规则

包rlp使用反射，根据值的Go类型编码RLP。

如果类型实现了Encoder接口，则Encode调用EncodeRLP。它不会在nil指针值上调用EncodeRLP。

对于指针，将编码指向的值。对于指向结构体类型、切片或数组的nil指针，除非切片或数组的元素类型为byte，否则始终编码为空RLP列表。指向其他值的nil指针编码为空字符串。

结构体值被编码为其所有编码公共字段的RLP列表。支持递归结构类型。

要对切片和数组进行编码，元素将编码为值的元素的RLP列表。请注意，元素类型为uint8或byte的数组和切片始终被编码为RLP字符串。

Go字符串被编码为RLP字符串。

无符号整数值被编码为RLP字符串。零始终编码为空RLP字符串。big.Int值被视为整数。不支持有符号整数（int、int8、int16等），在编码时将返回错误。

布尔值被编码为无符号整数零（false）和一（true）。

接口值编码为接口中包含的值。

不支持浮点数、映射、通道和函数。

# 解码规则

解码使用以下类型相关规则：

如果类型实现了Decoder接口，则调用DecodeRLP。

要解码为指针，将解码值作为指针的元素类型。如果指针为nil，则分配指针的元素类型的新值。如果指针不为nil，则重用现有值。请注意，包rlp从不将指针类型的结构字段保留为nil，除非存在“nil”结构标记之一。

要解码为结构体，解码器期望输入为RLP列表。列表的解码元素按照结构体定义给定的顺序分配给每个公共字段。输入列表必须包含每个解码字段的元素。如果结构体的元素过少或过多，则解码将返回错误。

要解码为切片，输入必须是一个列表，生成的切片将按顺序包含输入元素。对于字节切片，输入必须是一个RLP字符串。数组类型类似解码，但有额外的限制，即输入元素（或字节）的数量必须与数组的定义长度匹配。

要解码为Go字符串，输入必须是RLP字符串。输入字节按原样获取，不一定是有效的UTF-8。

要解码为无符号整数类型，输入也必须是RLP字符串。字节被解释为整数的大端表示。如果RLP字符串大于类型的位大小，则解码将返回错误。Decode还支持*big.Int。大整数没有大小限制。

要解码为布尔值，输入必须包含值为零（false）或一（true）的无符号整数。

要解码为接口值，这些类型之一存储在值中：

[]interface{}，用于RLP列表
[]byte，用于RLP字符串

不支持非空接口类型的解码。无法将有符号整数、浮点数、映射、通道和函数解码为值。

# 结构体标记

与其他编码包一样，“-”标记忽略字段。

    type StructWithIgnoredField struct{
        Ignored uint `rlp:"-"`
        Field   uint
    }

Go结构体值编码/解码为RLP列表。影响字段到列表元素的映射有两种方式。仅可用于最后一个导出结构字段的“tail”标记，允许将任何多余的列表元素捆绑到一个切片中。

    type StructWithTail struct{
        Field   uint
        Tail    []string `rlp:"tail"`
    }

“optional”标记表示如果该字段为零值，则可以省略该字段。如果在结构字段上使用此标记，则所有后续的公共字段也必须声明为可选。

在编码具有可选字段的结构体时，输出RLP列表包含所有值，直到最后一个非零可选字段。

在解码为结构体时，可以从输入列表的末尾省略可选字段。对于下面的示例，这意味着接受一个、两个或三个元素的输入列表。

    type StructWithOptionalFields struct{
         Required  uint
         Optional1 uint `rlp:"optional"`
         Optional2 uint `rlp:"optional"`
    }

“nil”、“nilList”和“nilString”标记仅适用于指针类型字段，并更改字段类型的解码规则。对于没有“nil”标记的常规指针字段，输入值必须始终精确匹配所需的输入长度，并且解码器不会生成nil值。当设置了“nil”标记时，大小为零的输入值解码为nil指针。这对于递归类型特别有用。

    type StructWithNilField struct {
        Field *[3]byte `rlp:"nil"`
    }

在上面的示例中，Field允许两种可能的输入大小。对于输入0xC180（包含空字符串的列表），Field在解码后设置为nil。对于输入0xC483000000（包含3字节字符串的列表），Field设置为非nil数组指针。

RLP支持两种类型的空值：空列表和空字符串。使用“nil”标记时，自动选择类型的空值。Go类型为指向无符号整数、字符串、布尔值或字节数组/切片的指针字段期望空的RLP字符串。任何其他指针字段类型均编码/解码为空RLP列表。

空值的选择可以使用“nilList”和“nilString”结构标记显式指定。使用这些标记将Go nil指针值编码/解码为由标记定义的空RLP值类型。