# 以太坊的trie树管理 回滚等操作 state源码分析
`core/state` 包主要为以太坊的state trie提供了一层缓存层(cache)

state的结构主要如下图

<img src="../../img/state_1.png">

蓝色的矩形代表本模块， 灰色的矩形代表外部模块。
- database主要提供了trie树的抽象，提供trie树的缓存和合约代码长度的缓存。
- journal主要提供了操作日志，以及操作回滚的功能。
- state_object是account对象的抽象，提供了账户的一些功能。
- statedb主要是提供了state trie的部分功能。

## database.go
database.go 提供了一个数据库的抽象。

### 数据结构
```go
// Database接口封装了对trie和合约代码的访问。
type Database interface {
	// OpenTrie打开主账户trie。
	OpenTrie(root common.Hash) (Trie, error)

	// OpenStorageTrie打开账户的存储trie。
	OpenStorageTrie(stateRoot common.Hash, addrHash, root common.Hash) (Trie, error)

	// CopyTrie返回给定trie的独立副本。
	CopyTrie(Trie) Trie

	// ContractCode检索特定合约的代码。
	ContractCode(addrHash, codeHash common.Hash) ([]byte, error)

	// ContractCodeSize检索特定合约代码的大小。
	ContractCodeSize(addrHash, codeHash common.Hash) (int, error)

	// DiskDB返回底层的键值对磁盘数据库。
	DiskDB() ethdb.KeyValueStore

	// TrieDB检索用于数据存储的底层trie数据库。
	TrieDB() *trie.Database
}

// NewDatabase函数创建一个用于存储状态的后端存储。
// 返回的数据库可以安全地进行并发使用，但不会在内存中保留任何最近的Trie节点。
// 要在内存中保留一些历史状态，请使用NewDatabaseWithConfig构造函数。
func NewDatabase(db ethdb.Database) Database {
    return NewDatabaseWithConfig(db, nil)
}

type cachingDB struct {
    disk          ethdb.KeyValueStore
    codeSizeCache *lru.Cache[common.Hash, int]
    codeCache     *lru.SizeConstrainedCache[common.Hash, []byte]
    triedb        *trie.Database
}
```

### OpenTrie
~~从缓存里面查找。如果找到了返回缓存的trie的copy， 否则重新构建一颗树返回。~~
```go
// OpenTrie函数用于打开指定根哈希的主账户Trie。
func (db *cachingDB) OpenTrie(root common.Hash) (Trie, error) {
	tr, err := trie.NewStateTrie(trie.StateTrieID(root), db.triedb)
	if err != nil {
		return nil, err
	}
	return tr, nil
}


// NewStateTrie函数从一个后备数据库中创建一个带有现有根节点的trie。
// 
// 如果根节点是零哈希或空字符串的sha3哈希，则trie最初为空。
// 否则，如果db为nil，New将会抛出panic，并且如果找不到根节点，则返回MissingNodeError。
func NewStateTrie(id *ID, db *Database) (*StateTrie, error) {
    if db == nil {
        panic("trie.NewStateTrie called without a database")
    }
    trie, err := New(id, db)
    if err != nil {
        return nil, err
    }
    return &StateTrie{trie: *trie, preimages: db.preimages}, nil
}

// OpenStorageTrie函数打开一个账户的存储trie
func (db *cachingDB) OpenStorageTrie(stateRoot common.Hash, addrHash, root common.Hash) (Trie, error) {
    tr, err := trie.NewStateTrie(trie.StorageTrieID(stateRoot, addrHash, root), db.triedb)
    if err != nil {
        return nil, err
    }
    return tr, nil
}
```

`New` 函数接受一个ID类型和一个NodeReader类型参数，ID是用于唯一标识Trie的标识符，NodeReader包装了访问Trie节点所需的所有必要函数。先新建一颗Trie树，如果`id.Root`不是空值的话，就说明是从数据库加载一个已经存在的Trie树， 就调用`trie.resolveAndTrack()`方法来加载整颗Trie树，如果root是空，那么就直接返回。

### ContractCode 和 ContractCodeSize
ContractCodeSize有缓存。
```go
// ContractCode函数检索特定合约的代码。
func (db *cachingDB) ContractCode(addrHash, codeHash common.Hash) ([]byte, error) {
	code, _ := db.codeCache.Get(codeHash)
	if len(code) > 0 {
		return code, nil
	}
	code = rawdb.ReadCode(db.disk, codeHash)
	if len(code) > 0 {
		db.codeCache.Add(codeHash, code)
		db.codeSizeCache.Add(codeHash, len(code))
		return code, nil
	}
	return nil, errors.New("not found")
}

// ContractCodeSize函数检索特定合约代码的大小。
func (db *cachingDB) ContractCodeSize(addrHash, codeHash common.Hash) (int, error) {
    if cached, ok := db.codeSizeCache.Get(codeHash); ok {
        return cached, nil
    }
    code, err := db.ContractCode(addrHash, codeHash)
    return len(code), err
}
```
`ContractCode` ：先从缓存中获取，没获取到则从磁盘中获取，并将代码和代码大小放到缓存
`ContractCodeSize` ：从缓存中获取代码大小，没获取到则从磁盘获取

### ~~cachedTrie~~ $\Rightarrow$ StateTrie
~~cachedTrie的commit方法commit的时候会调用pushTrie方法把之前的Trie树缓存起来。~~
```go
// SecureTrie is the old name of StateTrie.
// Deprecated: use StateTrie.
type SecureTrie = StateTrie

// StateTrie是一个带有键哈希的trie的封装。
// 在StateTrie中，所有访问操作都使用keccak256对键进行哈希。
// 这可以防止调用代码创建增加访问时间的长节点链。
//
// 与常规trie相反，StateTrie只能通过New创建，并且必须附加一个数据库。
// 数据库还存储了每个键的原像，如果启用了原像记录。
//
// StateTrie不适用于并发使用。
type StateTrie struct {
    trie             Trie
    preimages        *preimageStore
    hashKeyBuf       [common.HashLength]byte
    secKeyCache      map[string][]byte
    secKeyCacheOwner *StateTrie // 指向自身的指针，在不匹配时替换键缓存
}

// Commit函数会收集Trie中的所有脏节点，并用相应的节点哈希替换它们。
// 所有收集到的节点（包括脏叶节点，如果collectLeaf为true）将被封装到一个节点集中返回。
// 如果Trie是干净的（没有需要提交的内容），则返回的节点集可以为nil。
// 如果启用了预映像记录，所有缓存的预映像也将被刷新。一旦Trie被提交，它将不再可用。
// 必须使用新的根和更新的Trie数据库创建一个新的Trie以供后续使用。
func (t *StateTrie) Commit(collectLeaf bool) (common.Hash, *trienode.NodeSet) {
    // Write all the pre-images to the actual disk database
    if len(t.getSecKeyCache()) > 0 {
        if t.preimages != nil {
            preimages := make(map[common.Hash][]byte)
            for hk, key := range t.secKeyCache {
                preimages[common.BytesToHash([]byte(hk))] = key
            }
            t.preimages.insertPreimage(preimages)
        }
        t.secKeyCache = make(map[string][]byte)
    }
    // Commit the trie and return its modified nodeset.
    return t.trie.Commit(collectLeaf)
}
```

## journal.go
journal代表了操作日志， 并针对各种操作的日志提供了对应的回滚功能。 可以基于这个日志来做一些事务类型的操作。

### 类型定义
定义了`journalEntry`这个接口，提供了undo的功能。 journal 就是journalEntry的列表。
```go
// journalEntry is a modification entry in the state change journal that can be
// reverted on demand.
type journalEntry interface {
	// revert undoes the changes introduced by this journal entry.
	revert(*StateDB)

	// dirtied returns the Ethereum address modified by this journal entry.
	dirtied() *common.Address
}
```

各种不同的日志类型以及`revert`方法
```go
type (
	// 账户Trie的更改。
	createObjectChange struct {
		account *common.Address
	}
	resetObjectChange struct {
		account      *common.Address
		prev         *stateObject
		prevdestruct bool
		prevAccount  []byte
		prevStorage  map[common.Hash][]byte
	}
	suicideChange struct {
		account     *common.Address
		prev        bool // 账户是否已自杀
		prevbalance *big.Int
	}

	// 单个账户的更改。
	balanceChange struct {
		account *common.Address
		prev    *big.Int
	}
	nonceChange struct {
		account *common.Address
		prev    uint64
	}
	storageChange struct {
		account       *common.Address
		key, prevalue common.Hash
	}
	codeChange struct {
		account            *common.Address
		prevcode, prevhash []byte
	}

	// 其他状态值的更改。
	refundChange struct {
		prev uint64
	}
	addLogChange struct {
		txhash common.Hash
	}
	addPreimageChange struct {
		hash common.Hash
	}
	touchChange struct {
		account *common.Address
	}
	// 访问列表的更改
	accessListAddAccountChange struct {
		address *common.Address
	}
	accessListAddSlotChange struct {
		address *common.Address
		slot    *common.Hash
	}

	transientStorageChange struct {
		account       *common.Address
		key, prevalue common.Hash
	}
)

func (ch createObjectChange) revert(s *StateDB) {
	delete(s.stateObjects, *ch.account)
	delete(s.stateObjectsDirty, *ch.account)
}

func (ch resetObjectChange) revert(s *StateDB) {
	s.setStateObject(ch.prev)
	if !ch.prevdestruct {
		delete(s.stateObjectsDestruct, ch.prev.address)
	}
	if ch.prevAccount != nil {
		s.snapAccounts[ch.prev.addrHash] = ch.prevAccount
	}
	if ch.prevStorage != nil {
		s.snapStorage[ch.prev.addrHash] = ch.prevStorage
	}
}

func (ch suicideChange) revert(s *StateDB) {
	obj := s.getStateObject(*ch.account)
	if obj != nil {
		obj.suicided = ch.prev
		obj.setBalance(ch.prevbalance)
	}
}

...

```

## state_object.go
stateObject表示正在修改的以太坊帐户。

### 数据结构
```go
type Storage map[common.Hash]common.Hash

// stateObject表示正在修改的以太坊账户。
//
// 使用模式如下：
// 首先需要获取一个状态对象。
// 通过该对象可以访问和修改账户值。
// 最后，调用commitTrie将修改后的存储Trie写入数据库。
type stateObject struct {
	address  common.Address
	addrHash common.Hash // hash of ethereum address of the account
	data     types.StateAccount
	db       *StateDB

	// Write caches.
	trie Trie // 存储Trie，在首次访问时变为非nil值。
	code Code // 合约字节码，在加载代码时设置。

	originStorage  Storage // 原始条目的存储缓存，用于去重重写，在每个交易中重置。
	pendingStorage Storage // 需要刷新到磁盘的存储条目，在整个区块结束时。
	dirtyStorage   Storage // 在当前交易执行中已修改的存储条目。

	// 缓存标志。
	// 当一个对象被标记为自杀时，在状态转换的“更新”阶段，它将从Trie中删除。
	dirtyCode bool // true if the code was updated
	suicided  bool
	deleted   bool
}

// StateAccount是以太坊账户的共识表示形式。
// 这些对象存储在main account trie中。
type StateAccount struct {
    Nonce    uint64
    Balance  *big.Int
    Root     common.Hash // 存储trie的默克尔根
    CodeHash []byte
}
```

### 构造函数
```go
// newObject creates a state object.
func newObject(db *StateDB, address common.Address, data types.StateAccount) *stateObject {
	if data.Balance == nil {
		data.Balance = new(big.Int)
	}
	if data.CodeHash == nil {
		data.CodeHash = types.EmptyCodeHash.Bytes()
	}
	if data.Root == (common.Hash{}) {
		data.Root = types.EmptyRootHash
	}
	return &stateObject{
		db:             db,
		address:        address,
		addrHash:       crypto.Keccak256Hash(address[:]),
		data:           data,
		originStorage:  make(Storage),
		pendingStorage: make(Storage),
		dirtyStorage:   make(Storage),
	}
}
```

### RLP的编码方式，只会编码 Account对象。
```go
// EncodeRLP implements rlp.Encoder.
func (s *stateObject) EncodeRLP(w io.Writer) error {
	return rlp.Encode(w, &s.data)
}
```

### 一些状态改变的函数。
```go
// 当一个对象被标记为自杀时，在状态转换的“更新”阶段，它将从Trie中删除
func (s *stateObject) markSuicided() {
	s.suicided = true
}

func (s *stateObject) touch() {
    s.db.journal.append(touchChange{
        account: &s.address,
    })
    if s.address == ripemd {
        // 将其明确地放入dirty-cache中，否则会从扁平化的日志中生成dirty-cache。
        s.db.journal.dirty(s.address)
    }
}
```

### Storage的处理
```go
// getTrie返回关联的storage trie。如果之前没有加载，则会打开trie。如果无法加载trie，将返回错误。
func (s *stateObject) getTrie(db Database) (Trie, error) {
    if s.trie == nil {
        // 首先尝试从预取器中获取
        // 我们不预取空的trie
        if s.data.Root != types.EmptyRootHash && s.db.prefetcher != nil {
            // 当矿工创建挂起状态时，没有预取器
            s.trie = s.db.prefetcher.trie(s.addrHash, s.data.Root)
        }
        if s.trie == nil {
            tr, err := db.OpenStorageTrie(s.db.originalRoot, s.addrHash, s.data.Root)
            if err != nil {
                return nil, err
            }
            s.trie = tr
        }
    }
    return s.trie, nil
}

// GetState从account storage trie中检索一个值。
func (s *stateObject) GetState(db Database, key common.Hash) common.Hash {
    // 如果该状态条目有一个脏值，则返回它
    value, dirty := s.dirtyStorage[key]
    if dirty {
        return value
    }
    // 否则返回条目的原始值
    return s.GetCommittedState(db, key)
}

// GetCommittedState从已提交的account storage trie中检索一个值。
func (s *stateObject) GetCommittedState(db Database, key common.Hash) common.Hash {
    // 如果有待处理的写入或已缓存的干净数据，则返回该值
    if value, pending := s.pendingStorage[key]; pending {
        return value
    }
    if value, cached := s.originStorage[key]; cached {
        return value
    }
    // 如果对象在*此*区块中被销毁（并可能复活），
    // 存储已被清除，我们不应该向前一个数据库查询任何存储值。
    // 可能的替代方案有：
    //   1）发生了复活，并设置了新的槽值-这些应该通过上面的pendingStorage处理。
    //   2）我们没有新值，并且可以返回空响应
    if _, destructed := s.db.stateObjectsDestruct[s.address]; destructed {
        return common.Hash{}
    }
    // 如果没有可用的活动对象，则尝试使用快照
    var (
        enc   []byte
        err   error
        value common.Hash
    )
    if s.db.snap != nil {
        start := time.Now()
        enc, err = s.db.snap.Storage(s.addrHash, crypto.Keccak256Hash(key.Bytes()))
        if metrics.EnabledExpensive {
            s.db.SnapshotStorageReads += time.Since(start)
        }
        if len(enc) > 0 {
            _, content, _, err := rlp.Split(enc)
            if err != nil {
                s.db.setError(err)
            }
            value.SetBytes(content)
        }
    }
    // 如果快照不可用或读取失败，则从数据库加载。
    if s.db.snap == nil || err != nil {
        start := time.Now()
        tr, err := s.getTrie(db)
        if err != nil {
            s.db.setError(err)
            return common.Hash{}
        }
        val, err := tr.GetStorage(s.address, key.Bytes())
        if metrics.EnabledExpensive {
            s.db.StorageReads += time.Since(start)
        }
        if err != nil {
            s.db.setError(err)
            return common.Hash{}
        }
        value.SetBytes(val)
    }
    s.originStorage[key] = value
    return value
}

// SetState函数用于更新账户存储中的值。
func (s *stateObject) SetState(db Database, key, value common.Hash) {
    // 如果新值与旧值相同，则不进行设置
    prev := s.GetState(db, key)
    if prev == value {
        return
    }
    // 新值不同，进行更新并记录变化
    s.db.journal.append(storageChange{
        account:  &s.address,
        key:      key,
        prevalue: prev,
    })
    s.setState(key, value)
}

func (s *stateObject) setState(key, value common.Hash) {
    s.dirtyStorage[key] = value
}
```

### 提交 Commit
```go
// commitTrie将存储更改提交到存储trie并重新计算根节点。
// 此外，所有trie更改将被收集在一个节点集中并返回。
func (s *stateObject) commitTrie(db Database) (*trienode.NodeSet, error) {
    tr, err := s.updateTrie(db)
    if err != nil {
        return nil, err
    }
    // 如果没有任何更改，不需要提交任何内容
    if tr == nil {
        return nil, nil
    }
    // 跟踪在提交存储trie上浪费的时间
    if metrics.EnabledExpensive {
        defer func(start time.Time) { s.db.StorageCommits += time.Since(start) }(time.Now())
    }
    root, nodes := tr.Commit(false)
    s.data.Root = root
    return nodes, nil
}
```

其中调用了updateTrie
```go
// updateTrie将缓存的存储修改写入对象的存储Trie中。
// 如果Trie尚未加载且没有进行任何修改，则返回nil。如果无法正确加载/更新Trie，则返回错误。
func (s *stateObject) updateTrie(db Database) (Trie, error) {
	// 确保所有脏槽位都被最终化到待处理存储区
	s.finalise(false) // 不再预取，如果需要直接获取
	if len(s.pendingStorage) == 0 {
		return s.trie, nil
	}
	// 跟踪在更新存储Trie上浪费的时间量
	if metrics.EnabledExpensive {
		defer func(start time.Time) { s.db.StorageUpdates += time.Since(start) }(time.Now())
	}
	// 对象的快照存储映射
	var (
		storage map[common.Hash][]byte
		hasher  = s.db.hasher
	)
	tr, err := s.getTrie(db)
	if err != nil {
		s.db.setError(err)
		return nil, err
	}
	// 将所有待处理的更新插入到Trie中
	usedStorage := make([][]byte, 0, len(s.pendingStorage))
	for key, value := range s.pendingStorage {
		// 跳过无操作的更改，持久化实际更改
		if value == s.originStorage[key] {
			continue
		}
		s.originStorage[key] = value

		// 用于快照的rlp编码值
		var snapshotVal []byte
		if (value == common.Hash{}) {
			if err := tr.DeleteStorage(s.address, key[:]); err != nil {
				s.db.setError(err)
				return nil, err
			}
			s.db.StorageDeleted += 1
		} else {
			trimmedVal := common.TrimLeftZeroes(value[:])
			// 编码[]byte不会失败，可以忽略错误。
			snapshotVal, _ = rlp.EncodeToBytes(trimmedVal)
			if err := tr.UpdateStorage(s.address, key[:], trimmedVal); err != nil {
				s.db.setError(err)
				return nil, err
			}
			s.db.StorageUpdated += 1
		}
		// 如果状态快照处于活动状态，则缓存数据直到提交
		if s.db.snap != nil {
			if storage == nil {
				// 检索旧的存储映射，如果可用，则创建一个新的
				if storage = s.db.snapStorage[s.addrHash]; storage == nil {
					storage = make(map[common.Hash][]byte)
					s.db.snapStorage[s.addrHash] = storage
				}
			}
			storage[crypto.HashData(hasher, key[:])] = snapshotVal // 如果已删除，则为nil
		}
		usedStorage = append(usedStorage, common.CopyBytes(key[:])) // 闭包需要复制
	}
	if s.db.prefetcher != nil {
		s.db.prefetcher.used(s.addrHash, s.data.Root, usedStorage)
	}
	if len(s.pendingStorage) > 0 {
		s.pendingStorage = make(Storage)
	}
	return tr, nil
}
```







