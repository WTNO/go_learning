genesis 是创世区块的意思. 一个区块链就是从同一个创世区块开始,通过规则形成的.不同的网络有不同的创世区块, 主网络和测试网路的创世区块是不同的.

这个模块根据传入的genesis的初始值和database，来设置genesis的状态，如果不存在创世区块，那么在database里面创建它。

### 数据结构
```go
// Genesis指定了创世块的头部字段和状态。它还通过链配置定义了硬分叉切换块。
type Genesis struct {
	Config     *params.ChainConfig `json:"config"`      // 链配置
	Nonce      uint64              `json:"nonce"`       // 随机数
	Timestamp  uint64              `json:"timestamp"`   // 时间戳
	ExtraData  []byte              `json:"extraData"`   // 额外数据
	GasLimit   uint64              `json:"gasLimit"   gencodec:"required"`  // Gas限制
	Difficulty *big.Int            `json:"difficulty" gencodec:"required"`  // 难度
	Mixhash    common.Hash         `json:"mixHash"`     // 混合哈希
	Coinbase   common.Address      `json:"coinbase"`    // 矿工地址
	Alloc      GenesisAlloc        `json:"alloc"      gencodec:"required"`  // 分配给账户的初始余额

	// 这些字段仅用于共识测试，请不要在实际的创世块中使用它们。
	Number     uint64      `json:"number"`      // 块编号
	GasUsed    uint64      `json:"gasUsed"`     // 已使用的Gas数量
	ParentHash common.Hash `json:"parentHash"`  // 父区块哈希
	BaseFee    *big.Int    `json:"baseFeePerGas"`  // 每单位Gas的基础费用
}
```

### SetupGenesisBlock
```go
// SetupGenesisBlock 在数据库中编写或更新创世块。
// 将使用的区块如下：
//
//                    创世块为空（nil）        创世块不为空（非nil）
//                 +------------------------------------------
//	数据库无创世块   |  主网默认值             |  创世块
//	数据库有创世块   |  来自数据库              |  创世块（如果兼容）
//
// 如果存储的链配置兼容（即不指定低于本地头块的分叉块），则将更新。
// 如果存在冲突，则错误为 *params.ConfigCompatError，并返回新的、未写入的配置。
//
// 返回的链配置永不为空。
func SetupGenesisBlock(db ethdb.Database, triedb *trie.Database, genesis *Genesis) (*params.ChainConfig, common.Hash, error) {
	return SetupGenesisBlockWithOverride(db, triedb, genesis, nil)
}

func SetupGenesisBlockWithOverride(db ethdb.Database, triedb *trie.Database, genesis *Genesis, overrides *ChainOverrides) (*params.ChainConfig, common.Hash, error) {
	if genesis != nil && genesis.Config == nil {
		return params.AllEthashProtocolChanges, common.Hash{}, errGenesisNoConfig
	}
	applyOverrides := func(config *params.ChainConfig) {
		if config != nil {
			if overrides != nil && overrides.OverrideCancun != nil {
				config.CancunTime = overrides.OverrideCancun
			}
		}
	}
	// 如果没有存储的创世块，只需提交新的块。
	stored := rawdb.ReadCanonicalHash(db, 0)
	if (stored == common.Hash{}) {
		if genesis == nil {
			log.Info("正在写入默认的主网创世块")
			genesis = DefaultGenesisBlock()
		} else {
			log.Info("正在写入自定义创世块")
		}
		block, err := genesis.Commit(db, triedb)
		if err != nil {
			return genesis.Config, common.Hash{}, err
		}
		applyOverrides(genesis.Config)
		return genesis.Config, block.Hash(), nil
	}
	// 我们在数据库中有创世块（可能在古老的数据库中），但对应的状态丢失。
	header := rawdb.ReadHeader(db, stored, 0)
	if header.Root != types.EmptyRootHash && !rawdb.HasLegacyTrieNode(db, header.Root) {
		if genesis == nil {
			genesis = DefaultGenesisBlock()
		}
		// 确保存储的创世块与给定的创世块匹配。
		hash := genesis.ToBlock().Hash()
		if hash != stored {
			return genesis.Config, hash, &GenesisMismatchError{stored, hash}
		}
		block, err := genesis.Commit(db, triedb)
		if err != nil {
			return genesis.Config, hash, err
		}
		applyOverrides(genesis.Config)
		return genesis.Config, block.Hash(), nil
	}
	// 检查创世块是否已经写入。
	if genesis != nil {
		hash := genesis.ToBlock().Hash()
		if hash != stored {
			return genesis.Config, hash, &GenesisMismatchError{stored, hash}
		}
	}
	// 获取现有的链配置。
	newcfg := genesis.configOrDefault(stored)
	applyOverrides(newcfg)
	if err := newcfg.CheckConfigForkOrder(); err != nil {
		return newcfg, common.Hash{}, err
	}
	storedcfg := rawdb.ReadChainConfig(db, stored)
	if storedcfg == nil {
		log.Warn("找到了没有链配置的创世块")
		rawdb.WriteChainConfig(db, stored, newcfg)
		return newcfg, stored, nil
	}
	storedData, _ := json.Marshal(storedcfg)
	// 特殊情况：如果使用私有网络（没有创世块，也没有主网哈希在数据库中），我们不能应用 `configOrDefault` 链配置，因为它将是 AllProtocolChanges（在现有私有网络创世块之上应用任何新的分叉）。在这种情况下，只应用覆盖项。
	if genesis == nil && stored != params.MainnetGenesisHash {
		newcfg = storedcfg
		applyOverrides(newcfg)
	}
	// 检查配置兼容性并写入配置。如果新旧配置相同，则不覆盖。
	if newData, _ := json.Marshal(newcfg); !bytes.Equal(storedData, newData) {
		rawdb.WriteChainConfig(db, stored, newcfg)
	}
	return newcfg, stored, nil
}
```







































