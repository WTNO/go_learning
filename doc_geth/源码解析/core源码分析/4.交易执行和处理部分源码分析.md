## StateTransition
### 状态转换模型
```go
// StateTransition 表示状态转换。
//
// == 状态转换模型 ==
//
// 当一个交易被应用到当前世界状态时，状态转换是一个所做的改变。状态转换模型会完成所有必要的工作，以计算出一个有效的新状态根。
//
// 1. Nonce 处理
// 2. 预支付燃料费用
// 3. 如果收款人为空，创建一个新的状态对象
// 4. 值转移
//
// == 如果是合约创建 ==
//
// 4a. 尝试运行交易数据
// 4b. 如果有效，将结果用作新状态对象的代码
//
// == 结束 ==
//
// 5. 运行脚本部分
// 6. 推导新的状态根
type StateTransition struct {
	gp           *GasPool
	msg          *Message
	gasRemaining uint64
	initialGas   uint64
	state        vm.StateDB
	evm          *vm.EVM
}

// 一个消息包含从单个交易中派生的与状态处理相关的数据。
type Message struct {
    To         *common.Address  // 接收地址
    From       common.Address   // 发送地址
    Nonce      uint64           // 交易序号
    Value      *big.Int         // 交易金额
    GasLimit   uint64           // 燃料限制
    GasPrice   *big.Int         // 燃料价格
    GasFeeCap  *big.Int         // 燃料费上限
    GasTipCap  *big.Int         // 燃料小费上限
    Data       []byte           // 交易数据
    AccessList types.AccessList // 访问列表
    BlobHashes []common.Hash    // Blob哈希列表
    
    // 当SkipAccountChecks为true时，消息的序号不会与状态中的账户序号进行检查。
    // 它还禁止检查发送方是否为EOA（外部拥有账户）。
    // 此字段在诸如RPC eth_call的操作中将设置为true。
    SkipAccountChecks bool
}
```

### 构造函数
```go
// NewStateTransition initialises and returns a new state transition object.
func NewStateTransition(evm *vm.EVM, msg *Message, gp *GasPool) *StateTransition {
	return &StateTransition{
		gp:    gp,
		evm:   evm,
		msg:   msg,
		state: evm.StateDB,
	}
}
```

### 执行Message
```go
// ApplyMessage函数通过在环境中将给定的消息应用于旧状态，计算新的状态。
//
// ApplyMessage函数返回任何EVM执行返回的字节（如果执行发生），
// 使用的燃料（包括燃料退款）以及如果执行失败则返回错误。
// 错误始终表示核心错误，意味着该消息在特定状态下总是会失败，并且永远不会被区块接受。
func ApplyMessage(evm *vm.EVM, msg *Message, gp *GasPool) (*ExecutionResult, error) {
	return NewStateTransition(evm, msg, gp).TransitionDb()
}
```

TransitionDb
```go
// TransitionDb函数将通过应用当前消息来过渡状态，并返回带有以下字段的evm执行结果。
//
//   - used gas: 使用的总gas（包括退还的gas）
//   - returndata: evm返回的数据
//   - concrete execution error: 终止执行的各种EVM错误，例如ErrOutOfGas、ErrExecutionReverted
//
// 但是，如果遇到任何共识问题，则直接返回错误和空的evm执行结果。
func (st *StateTransition) TransitionDb() (*ExecutionResult, error) {
	// 在应用消息之前，首先检查该消息是否满足所有共识规则。规则包括以下条款：
	//
	// 1. 消息调用者的nonce是否正确
	// 2. 调用者是否有足够的余额来支付交易费用（gaslimit * gasprice）
	// 3. 所需的gas数量是否在区块中可用
	// 4. 购买的gas是否足以覆盖内在使用量
	// 5. 计算内在gas时是否存在溢出
	// 6. 调用者是否有足够的余额来支付**最顶层**调用的资产转移

	// 检查条款1-3，如果一切正确则购买gas
	if err := st.preCheck(); err != nil {
		return nil, err
	}

	if tracer := st.evm.Config.Tracer; tracer != nil {
		tracer.CaptureTxStart(st.initialGas)
		defer func() {
			tracer.CaptureTxEnd(st.gasRemaining)
		}()
	}

	var (
		msg              = st.msg
		sender           = vm.AccountRef(msg.From)
		rules            = st.evm.ChainConfig().Rules(st.evm.Context.BlockNumber, st.evm.Context.Random != nil, st.evm.Context.Time)
		contractCreation = msg.To == nil
	)

	// 检查条款4-5，如果一切正确则减去内在gas
	gas, err := IntrinsicGas(msg.Data, msg.AccessList, contractCreation, rules.IsHomestead, rules.IsIstanbul, rules.IsShanghai)
	if err != nil {
		return nil, err
	}
	if st.gasRemaining < gas {
		return nil, fmt.Errorf("%w: 现有 %d，期望 %d", ErrIntrinsicGas, st.gasRemaining, gas)
	}
	st.gasRemaining -= gas

	// 检查条款6
	if msg.Value.Sign() > 0 && !st.evm.Context.CanTransfer(st.state, msg.From, msg.Value) {
		return nil, fmt.Errorf("%w: 地址 %v", ErrInsufficientFundsForTransfer, msg.From.Hex())
	}

	// 检查初始化代码大小是否超过限制。
	if rules.IsShanghai && contractCreation && len(msg.Data) > params.MaxInitCodeSize {
		return nil, fmt.Errorf("%w: 代码大小 %v 限制 %v", ErrMaxInitCodeSizeExceeded, len(msg.Data), params.MaxInitCodeSize)
	}

	// 执行状态过渡的准备步骤，包括：
	// - 准备访问列表（post-berlin）
	// - 重置临时存储（eip 1153）
	st.state.Prepare(rules, msg.From, st.evm.Context.Coinbase, msg.To, vm.ActivePrecompiles(rules), msg.AccessList)

	var (
		ret   []byte
		vmerr error // vm错误不影响共识，因此不分配给err
	)
	if contractCreation {
		ret, _, st.gasRemaining, vmerr = st.evm.Create(sender, msg.Data, st.gasRemaining, msg.Value)
	} else {
		// 递增下一笔交易的nonce
		st.state.SetNonce(msg.From, st.state.GetNonce(sender.Address())+1)
		ret, st.gasRemaining, vmerr = st.evm.Call(sender, st.to(), msg.Data, st.gasRemaining, msg.Value)
	}

	if !rules.IsLondon {
		// 在EIP-3529之前：退款被限制为gasUsed / 2
		st.refundGas(params.RefundQuotient)
	} else {
		// 在EIP-3529之后：退款被限制为gasUsed / 5
		st.refundGas(params.RefundQuotientEIP3529)
	}
	effectiveTip := msg.GasPrice
	if rules.IsLondon {
		effectiveTip = cmath.BigMin(msg.GasTipCap, new(big.Int).Sub(msg.GasFeeCap, st.evm.Context.BaseFee))
	}

	if st.evm.Config.NoBaseFee && msg.GasFeeCap.Sign() == 0 && msg.GasTipCap.Sign() == 0 {
		// 当设置了NoBaseFee并且费用字段为0时，跳过费用支付。这样可以避免在模拟调用时向coinbase应用负的effectiveTip。
	} else {
		fee := new(big.Int).SetUint64(st.gasUsed())
		fee.Mul(fee, effectiveTip)
		st.state.AddBalance(st.evm.Context.Coinbase, fee)
	}

	return &ExecutionResult{
		UsedGas:    st.gasUsed(),
		Err:        vmerr,
		ReturnData: ret,
	}, nil
}
```















































