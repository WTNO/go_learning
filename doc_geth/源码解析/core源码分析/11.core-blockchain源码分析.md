从测试案例来看,blockchain的主要功能点有下面几点.
1. import.
2. GetLastBlock的功能.
3. 如果有多条区块链,可以选取其中难度最大的一条作为规范的区块链.
4. BadHashes 可以手工禁止接受一些区块的hash值.在blocks.go里面.
5. 如果新配置了BadHashes. 那么区块启动的时候会自动禁止并进入有效状态.
6. 错误的nonce会被拒绝.
7. 支持Fast importing.
8. Light vs Fast vs Full processing 在处理区块头上面的效果相等.

可以看到blockchain的主要功能是维护区块链的状态, 包括区块的验证,插入和状态查询.

### 名词解释:
什么是规范的区块链？

因为在区块的创建过程中,可能在短时间内产生一些分叉, 在我们的数据库里面记录的其实是一颗区块树.我们会认为其中总难度最高的一条路径认为是我们的规范的区块链. 这样有很多区块虽然也能形成区块链,但是不是规范的区块链.

### 数据库结构(暂时没看懂)
```go
区块的hash值和区块头的hash值是同样的么。所谓的区块的Hash值其实就是Header的区块值。
// key -> value
// + 代表连接

"LastHeader"  最新的区块头 HeaderChain中使用
"LastBlock"   最新的区块头 BlockChain 中使用
"LastFast"    最新的快速同步的区块头

"h"+num+"n" -> hash  用来存储规范的区块链的高度和区块头的hash值

"h" + num + hash -> header 高度+hash值 -> 区块头

"h" + num + hash + "t" -> td  高度+hash值 -> 总难度

"H" + hash -> num  区块体hash -> 高度

"b" + num + hash -> block body   高度+hash值 -> 区块体

"r" + num + hash -> block receipts  高度 + hash值 -> 区块收据

"l" + hash -> transaction/receipt lookup metadata
```

|key | value|说明|插入|删除|
|---- | --- |---------------|-----------|-----------|
|"LastHeader" | hash | 最新的区块头 HeaderChain中使用|当区块被认为是当前最新的一个规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"LastBlock" |  hash | 最新的区块头 BlockChain中使用|当区块被认为是当前最新的一个规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"LastFast" | hash |  最新的区块头 BlockChain中使用|当区块被认为是当前最新的规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"h"+num+"n"|hash|用来存储规范的区块链的高度和区块头的hash值 在HeaderChain中使用|当区块在规范的区块链中|当区块不在规范的区块链中|
|"h" + num + hash + "t"|td|总难度|WriteBlockAndState当验证并执行完一个区块之后(不管是不是规范的)|SetHead方法会调用。这种方法只会在两种情况下被调用，1是当前区块链包含了badhashs，需要删除所有从badhashs开始的区块， 2.是当前区块的状态错误，需要Reset到genesis。|
|"H" + hash | num| 区块的高度 在HeaderChain中使用|WriteBlockAndState当验证并执行完一个区块之后|SetHead中被调用，同上|
|"b" + num + hash|block body| 区块数据| WriteBlockAndState or InsertReceiptChain|SetHead中被删除，同上|
|"r" + num + hash|block receipts|区块收据|WriteBlockAndState or InsertReceiptChain|同上|
|"l" + txHash | {hash,num,TxIndex|交易hash可以找到区块和交易|当区块加入规范的区块链|当区块从规范的区块链移除|

### 数据结构
```go
// BlockChain表示具有创世块的数据库中的规范链。Blockchain管理链的导入、回滚和链重组。
//
// 将块导入到区块链中是根据两阶段验证器定义的一组规则进行的。
// 块的处理是使用处理器进行的，处理其中包含的交易。
// 状态的验证是在验证器的第二部分中完成的。如果验证失败，则导入中止。
//
// BlockChain还有助于从数据库中包含的**任何**链返回块，以及代表规范链的块。
// 需要注意的是，GetBlock可以返回任何块，并不一定需要包含在规范链中，而GetBlockByNumber始终表示规范链。
type BlockChain struct {
	chainConfig *params.ChainConfig // 链和网络配置
	cacheConfig *CacheConfig        // 剪枝的缓存配置

	db            ethdb.Database                   // 用于存储最终内容的底层持久性数据库
	snaps         *snapshot.Tree                   // 用于快速trie叶子访问的快照树
	triegc        *prque.Prque[int64, common.Hash] // 将块号映射到要进行垃圾回收的tries的优先级队列
	gcproc        time.Duration                    // 积累规范块处理以进行trie转储
	lastWrite     uint64                           // 状态刷新时的最后一个块
	flushInterval atomic.Int64                     // 在此之后刷新状态的时间间隔（处理时间）
	triedb        *trie.Database                   // 用于维护trie节点的数据库处理程序。
	stateCache    state.Database                   // 在导入之间重用的状态数据库（包含状态缓存）

	// txLookupLimit是保留事务索引的从头部开始的最大块数：
	//  * 0:   表示没有限制，并重新生成任何丢失的索引
	//  * N:   表示N个块的限制[HEAD-N+1, HEAD]并删除额外的索引
	//  * nil: 禁用tx重新索引器/删除器，但仍然索引新的块
	txLookupLimit uint64

	hc            *HeaderChain
	rmLogsFeed    event.Feed
	chainFeed     event.Feed
	chainSideFeed event.Feed
	chainHeadFeed event.Feed
	logsFeed      event.Feed
	blockProcFeed event.Feed
	scope         event.SubscriptionScope
	genesisBlock  *types.Block

	// 此互斥锁同步链写操作。
	// 读者不需要获取它，只需读取数据库即可。
	chainmu *syncx.ClosableMutex

	currentBlock      atomic.Pointer[types.Header] // 链的当前头
	currentSnapBlock  atomic.Pointer[types.Header] // 当前快照同步的头
	currentFinalBlock atomic.Pointer[types.Header] // 最新（共识）的已最终化块
	currentSafeBlock  atomic.Pointer[types.Header] // 最新（共识）的安全块

	bodyCache     *lru.Cache[common.Hash, *types.Body]
	bodyRLPCache  *lru.Cache[common.Hash, rlp.RawValue]
	receiptsCache *lru.Cache[common.Hash, []*types.Receipt]
	blockCache    *lru.Cache[common.Hash, *types.Block]
	txLookupCache *lru.Cache[common.Hash, *rawdb.LegacyTxLookupEntry]

	// 未来块是添加以供稍后处理的块
	futureBlocks *lru.Cache[common.Hash, *types.Block]

	wg            sync.WaitGroup //
	quit          chan struct{}  // 关闭信号，在Stop中关闭。
	stopping      atomic.Bool    // 如果链正在运行，则为false，如果停止，则为true
	procInterrupt atomic.Bool    // 用于块处理的中断信号

	engine     consensus.Engine
	validator  Validator // 块和状态验证器接口
	prefetcher Prefetcher
	processor  Processor // 块事务处理器接口
	forker     *ForkChoice
	vmConfig   vm.Config
}
```

### 构造方法NewBlockChain
使用数据库里面的可用信息构造了一个初始化好的区块链. 同时初始化了以太坊默认的 验证器和处理器 (Validator and Processor)
```go
// NewBlockChain 返回一个完全初始化的区块链，使用数据库中可用的信息。
// 它初始化了默认的以太坊验证器和处理器。
func NewBlockChain(db ethdb.Database, cacheConfig *CacheConfig, genesis *Genesis, overrides *ChainOverrides, engine consensus.Engine, vmConfig vm.Config, shouldPreserve func(header *types.Header) bool, txLookupLimit *uint64) (*BlockChain, error) {
	if cacheConfig == nil {
		cacheConfig = defaultCacheConfig
	}
	// 使用提供的配置打开 trie 数据库
	triedb := trie.NewDatabaseWithConfig(db, &trie.Config{
		Cache:     cacheConfig.TrieCleanLimit,
		Journal:   cacheConfig.TrieCleanJournal,
		Preimages: cacheConfig.Preimages,
	})
	// 设置创世块，如果创世块尚不存在，则将提供的创世规范提交到数据库中，否则从数据库中加载已存储的创世块。
	chainConfig, genesisHash, genesisErr := SetupGenesisBlockWithOverride(db, triedb, genesis, overrides)
	if _, ok := genesisErr.(*params.ConfigCompatError); genesisErr != nil && !ok {
		return nil, genesisErr
	}
	log.Info("")
	log.Info(strings.Repeat("-", 153))
	for _, line := range strings.Split(chainConfig.Description(), "\n") {
		log.Info(line)
	}
	log.Info(strings.Repeat("-", 153))
	log.Info("")

	bc := &BlockChain{
		chainConfig:   chainConfig,
		cacheConfig:   cacheConfig,
		db:            db,
		triedb:        triedb,
		triegc:        prque.New[int64, common.Hash](nil),
		quit:          make(chan struct{}),
		chainmu:       syncx.NewClosableMutex(),
		bodyCache:     lru.NewCache[common.Hash, *types.Body](bodyCacheLimit),
		bodyRLPCache:  lru.NewCache[common.Hash, rlp.RawValue](bodyCacheLimit),
		receiptsCache: lru.NewCache[common.Hash, []*types.Receipt](receiptsCacheLimit),
		blockCache:    lru.NewCache[common.Hash, *types.Block](blockCacheLimit),
		txLookupCache: lru.NewCache[common.Hash, *rawdb.LegacyTxLookupEntry](txLookupCacheLimit),
		futureBlocks:  lru.NewCache[common.Hash, *types.Block](maxFutureBlocks),
		engine:        engine,
		vmConfig:      vmConfig,
	}
	bc.flushInterval.Store(int64(cacheConfig.TrieTimeLimit))
	bc.forker = NewForkChoice(bc, shouldPreserve)
	bc.stateCache = state.NewDatabaseWithNodeDB(bc.db, bc.triedb)
	bc.validator = NewBlockValidator(chainConfig, bc, engine)
	bc.prefetcher = newStatePrefetcher(chainConfig, bc, engine)
	bc.processor = NewStateProcessor(chainConfig, bc, engine)

	var err error
	bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.insertStopped)
	if err != nil {
		return nil, err
	}
	bc.genesisBlock = bc.GetBlockByNumber(0)
	if bc.genesisBlock == nil {
		return nil, ErrNoGenesis
	}

	bc.currentBlock.Store(nil)
	bc.currentSnapBlock.Store(nil)
	bc.currentFinalBlock.Store(nil)
	bc.currentSafeBlock.Store(nil)

	// 如果 Geth 初始化时使用外部古代存储，则重新初始化丢失的链索引和链标志。
	// 这个过程可以在崩溃后继续进行，并且可以在下一次重启中恢复，因为链标志在最后一步中更新。
	if bc.empty() {
		rawdb.InitDatabaseFromFreezer(bc.db)
	}
	// 从磁盘加载区块链状态
	if err := bc.loadLastState(); err != nil {
		return nil, err
	}
	// 确保与块关联的状态可用
	head := bc.CurrentBlock()
	if !bc.HasState(head.Root) {
		// 头状态丢失，在进行状态恢复之前，找出快照的磁盘层点（如果启用了快照）。
		// 确保回绕点低于磁盘层。
		var diskRoot common.Hash
		if bc.cacheConfig.SnapshotLimit > 0 {
			diskRoot = rawdb.ReadSnapshotRoot(bc.db)
		}
		if diskRoot != (common.Hash{}) {
			log.Warn("头状态丢失，修复中", "number", head.Number, "hash", head.Hash(), "snaproot", diskRoot)

			snapDisk, err := bc.setHeadBeyondRoot(head.Number.Uint64(), 0, diskRoot, true)
			if err != nil {
				return nil, err
			}
			// 链回绕，将旧快照号持久化以指示恢复过程
			if snapDisk != 0 {
				rawdb.WriteSnapshotRecoveryNumber(bc.db, snapDisk)
			}
		} else {
			log.Warn("头状态丢失，修复中", "number", head.Number, "hash", head.Hash())
			if _, err := bc.setHeadBeyondRoot(head.Number.Uint64(), 0, common.Hash{}, true); err != nil {
				return nil, err
			}
		}
	}
	// 确保 SetHead 中的上一次崩溃不会留下额外的古代块
	if frozen, err := bc.db.Ancients(); err == nil && frozen > 0 {
		var (
			needRewind bool
			low        uint64
		)
		// 由于区块链修复，完整块可能会回滚到非常低的高度。
		// 如果完整块甚至低于古代链，截断古代存储。
		fullBlock := bc.CurrentBlock()
		if fullBlock != nil && fullBlock.Hash() != bc.genesisBlock.Hash() && fullBlock.Number.Uint64() < frozen-1 {
			needRewind = true
			low = fullBlock.Number.Uint64()
		}
		// 在快速同步中，可能已将古代数据写入古代存储，但 LastFastBlock 尚未更新，此处截断额外数据。
		snapBlock := bc.CurrentSnapBlock()
		if snapBlock != nil && snapBlock.Number.Uint64() < frozen-1 {
			needRewind = true
			if snapBlock.Number.Uint64() < low || low == 0 {
				low = snapBlock.Number.Uint64()
			}
		}
		if needRewind {
			log.Error("截断古代链", "from", bc.CurrentHeader().Number.Uint64(), "to", low)
			if err := bc.SetHead(low); err != nil {
				return nil, err
			}
		}
	}
	// 节点的第一件事是重建头块的验证数据（ethash 缓存或 clique 投票快照），最好提前做。
	bc.engine.VerifyHeader(bc, bc.CurrentHeader())

	// 检查块哈希的当前状态，并确保我们的链中没有任何坏块
	for hash := range BadHashes {
		if header := bc.GetHeaderByHash(hash); header != nil {
			// 获取与有问题的头部的数字对应的规范块
			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())
			// 确保 headerByNumber（如果存在）在当前的规
            if headerByNumber != nil && headerByNumber.Hash() == header.Hash() {
                log.Error("Found bad hash, rewinding chain", "number", header.Number, "hash", header.ParentHash)
                if err := bc.SetHead(header.Number.Uint64() - 1); err != nil {
                    return nil, err
                }
                log.Error("Chain rewind was successful, resuming normal operation")
			}
		}
    }
    // 加载任何现有的快照，如果加载失败则重新生成
    if bc.cacheConfig.SnapshotLimit > 0 {
        // 如果链被回滚到快照持久层（导致恢复块号被持久化到磁盘），检查是否仍处于恢复模式，
		// 如果是，则在头不匹配的情况下不使快照失效。
        var recover bool
        
        head := bc.CurrentBlock()
        if layer := rawdb.ReadSnapshotRecoveryNumber(bc.db); layer != nil && *layer >= head.Number.Uint64() {
            log.Warn("启用快照恢复", "链头", head.Number, "磁盘基础", *layer)
            recover = true
        }
        snapconfig := snapshot.Config{
            CacheSize:  bc.cacheConfig.SnapshotLimit,
            Recovery:   recover,
            NoBuild:    bc.cacheConfig.SnapshotNoBuild,
            AsyncBuild: !bc.cacheConfig.SnapshotWait,
        }
        bc.snaps, _ = snapshot.New(snapconfig, bc.db, bc.triedb, head.Root)
    }
    
    // 启动未来区块处理器。
    bc.wg.Add(1)
    go bc.updateFutureBlocks()
    
    // 如果需要定期清理缓存日志，启动它。
    if bc.cacheConfig.TrieCleanRejournal > 0 {
        if bc.cacheConfig.TrieCleanRejournal < time.Minute {
            log.Warn("清理无效的Trie缓存日志时间", "提供的", bc.cacheConfig.TrieCleanRejournal, "更新为", time.Minute)
            bc.cacheConfig.TrieCleanRejournal = time.Minute
        }
        bc.wg.Add(1)
        go func() {
            defer bc.wg.Done()
            bc.triedb.SaveCachePeriodically(bc.cacheConfig.TrieCleanJournal, bc.cacheConfig.TrieCleanRejournal, bc.quit)
        }()
    }
    // 在不兼容的配置升级的情况下回滚链。
    if compat, ok := genesisErr.(*params.ConfigCompatError); ok {
        log.Warn("回滚链以升级配置", "错误", compat)
        if compat.RewindToTime > 0 {
            bc.SetHeadWithTimestamp(compat.RewindToTime)
        } else {
            bc.SetHead(compat.RewindToBlock)
        }
        rawdb.WriteChainConfig(db, genesisHash, chainConfig)
    }
    // 如果需要，启动交易索引器/反索引器。
    if txLookupLimit != nil {
        bc.txLookupLimit = *txLookupLimit
        
        bc.wg.Add(1)
        go bc.maintainTxIndex()
    }
    return bc, nil
}
```

### loadLastState
加载数据库里面的最新的我们知道的区块链状态. 这个方法假设已经获取到锁了.
```go
// loadLastState从数据库加载最后已知的链状态。该方法假设链管理器的互斥锁已经被持有。
func (bc *BlockChain) loadLastState() error {
	// 恢复最后已知的头块
	head := rawdb.ReadHeadBlockHash(bc.db)
	if head == (common.Hash{}) {
		// 数据库损坏或为空，从头开始初始化
		log.Warn("数据库为空，重置链")
		return bc.Reset()
	}
	// 确保整个头块可用
	headBlock := bc.GetBlockByHash(head)
	if headBlock == nil {
		// 数据库损坏或为空，从头开始初始化
		log.Warn("头块丢失，重置链", "hash", head)
		return bc.Reset()
	}
	// 一切似乎都正常，设置为头块
	bc.currentBlock.Store(headBlock.Header())
	headBlockGauge.Update(int64(headBlock.NumberU64()))

	// 恢复最后已知的头头部
	headHeader := headBlock.Header()
	if head := rawdb.ReadHeadHeaderHash(bc.db); head != (common.Hash{}) {
		if header := bc.GetHeaderByHash(head); header != nil {
			headHeader = header
		}
	}
	bc.hc.SetCurrentHeader(headHeader)

	// 恢复最后已知的快照块
	bc.currentSnapBlock.Store(headBlock.Header())
	headFastBlockGauge.Update(int64(headBlock.NumberU64()))

	if head := rawdb.ReadHeadFastBlockHash(bc.db); head != (common.Hash{}) {
		if block := bc.GetBlockByHash(head); block != nil {
			bc.currentSnapBlock.Store(block.Header())
			headFastBlockGauge.Update(int64(block.NumberU64()))
		}
	}

	// 恢复最后已知的最终块和安全块
	// 注意：安全块未存储在磁盘上，并在启动时设置为最后已知的最终块
	if head := rawdb.ReadFinalizedBlockHash(bc.db); head != (common.Hash{}) {
		if block := bc.GetBlockByHash(head); block != nil {
			bc.currentFinalBlock.Store(block.Header())
			headFinalizedBlockGauge.Update(int64(block.NumberU64()))
			bc.currentSafeBlock.Store(block.Header())
			headSafeBlockGauge.Update(int64(block.NumberU64()))
		}
	}
	// 向用户发出状态日志
	var (
		currentSnapBlock  = bc.CurrentSnapBlock()
		currentFinalBlock = bc.CurrentFinalBlock()

		headerTd = bc.GetTd(headHeader.Hash(), headHeader.Number.Uint64())
		blockTd  = bc.GetTd(headBlock.Hash(), headBlock.NumberU64())
	)
	if headHeader.Hash() != headBlock.Hash() {
		log.Info("加载最近的本地头部", "number", headHeader.Number, "hash", headHeader.Hash(), "td", headerTd, "age", common.PrettyAge(time.Unix(int64(headHeader.Time), 0)))
	}
	log.Info("加载最近的本地块", "number", headBlock.Number(), "hash", headBlock.Hash(), "td", blockTd, "age", common.PrettyAge(time.Unix(int64(headBlock.Time()), 0)))
	if headBlock.Hash() != currentSnapBlock.Hash() {
		fastTd := bc.GetTd(currentSnapBlock.Hash(), currentSnapBlock.Number.Uint64())
		log.Info("加载最近的本地快照块", "number", currentSnapBlock.Number, "hash", currentSnapBlock.Hash(), "td", fastTd, "age", common.PrettyAge(time.Unix(int64(currentSnapBlock.Time), 0)))
	}
	if currentFinalBlock != nil {
		finalTd := bc.GetTd(currentFinalBlock.Hash(), currentFinalBlock.Number.Uint64())
		log.Info("加载最近的本地最终块", "number", currentFinalBlock.Number, "hash", currentFinalBlock.Hash(), "td", finalTd, "age", common.PrettyAge(time.Unix(int64(currentFinalBlock.Time), 0)))
	}
	if pivot := rawdb.ReadLastPivotNumber(bc.db); pivot != nil {
		log.Info("加载最后的快速同步轴标记", "number", *pivot)
	}
	return nil
}
```

### updateFutureBlocks
goroutine update的处理非常简单. 定时处理future blocks.
```go
func (bc *BlockChain) updateFutureBlocks() {
	futureTimer := time.NewTicker(5 * time.Second)
	defer futureTimer.Stop()
	defer bc.wg.Done()
	for {
		select {
		case <-futureTimer.C:
			bc.procFutureBlocks()
		case <-bc.quit:
			return
		}
	}
}
```

### Reset
重置区块链.
```go
// Reset函数将整个区块链重置为创世状态。
func (bc *BlockChain) Reset() error {
	return bc.ResetWithGenesisBlock(bc.genesisBlock)
}

// ResetWithGenesisBlock函数将整个区块链重置为指定的创世状态。
func (bc *BlockChain) ResetWithGenesisBlock(genesis *types.Block) error {
	// 清空整个区块链并清除缓存
	if err := bc.SetHead(0); err != nil {
		return err
	}
	if !bc.chainmu.TryLock() {
		return errChainStopped
	}
	defer bc.chainmu.Unlock()

	// 准备创世块并重新初始化链
	batch := bc.db.NewBatch()
	rawdb.WriteTd(batch, genesis.Hash(), genesis.NumberU64(), genesis.Difficulty())
	rawdb.WriteBlock(batch, genesis)
	if err := batch.Write(); err != nil {
		log.Crit("写入创世块失败", "err", err)
	}
	bc.writeHeadBlock(genesis)

	// 最后更新所有内存中的链标记
	bc.genesisBlock = genesis
	bc.currentBlock.Store(bc.genesisBlock.Header())
	headBlockGauge.Update(int64(bc.genesisBlock.NumberU64()))
	bc.hc.SetGenesis(bc.genesisBlock.Header())
	bc.hc.SetCurrentHeader(bc.genesisBlock.Header())
	bc.currentSnapBlock.Store(bc.genesisBlock.Header())
	headFastBlockGauge.Update(int64(bc.genesisBlock.NumberU64()))
	return nil
}
```

### SetHead
将本地链回卷到新的头部。 在给定新header之上的所有内容都将被删除，新的header将被设置。 如果块体丢失（快速同步之后的非归档节点），头部可能被进一步倒回。
```go
// SetHead方法将本地链重置到一个新的头部。根据节点是快速同步还是完全同步，以及处于哪个状态，该方法将尝试在保持链一致性的同时尽可能删除最小的磁盘数据。
func (bc *BlockChain) SetHead(head uint64) error {
	if _, err := bc.setHeadBeyondRoot(head, 0, common.Hash{}, false); err != nil {
		return err
	}
	// 发送链头事件以更新交易池
	header := bc.CurrentBlock()
	block := bc.GetBlock(header.Hash(), header.Number.Uint64())
	if block == nil {
		// 这应该不会发生。实际上，先前的currentBlock包含整个块，而现在只有一个“标记”，所以有极低的竞争机会，我们应该处理。
		log.Error("数据库中找不到当前块", "块", header.Number, "哈希", header.Hash())
		return fmt.Errorf("当前块丢失：#%d [%x..]", header.Number, header.Hash().Bytes()[:4])
	}
	bc.chainHeadFeed.Send(ChainHeadEvent{Block: block})
	return nil
}
```

#### setHeadBeyondRoot
```go
// setHeadBeyondRoot方法将本地链重置为具有额外条件的新头部，该条件是重置必须通过指定的状态根。此方法旨在在启用快照的情况下使用，以确保我们回退的更远，而不是持久磁盘层。根据节点是快速同步还是完整同步以及处于哪个状态，该方法将尝试从磁盘中删除最少的数据，同时保持链的一致性。

// 如果`head == 0`但`time != 0`，该方法也可以在时间戳模式下工作。在这种情况下，块将回滚，直到新头部变得早于或等于请求的时间。如果`head`和`time`都为0，则链将回滚到创世块。

// 该方法返回找到请求的根哈希的块号。

func (bc *BlockChain) setHeadBeyondRoot(head uint64, time uint64, root common.Hash, repair bool) (uint64, error) {
	if !bc.chainmu.TryLock() {
		return 0, errChainStopped
	}
	defer bc.chainmu.Unlock()

	// 跟踪请求的根哈希的块号
	var rootNumber uint64 //（无根哈希 == 始终为0）

	// 检索上一个枢轴块以绕过它和当前冷冻器限制以开始删除已下溢的id
	pivot := rawdb.ReadLastPivotNumber(bc.db)
	frozen, _ := bc.db.Ancients()

	updateFn := func(db ethdb.KeyValueWriter, header *types.Header) (*types.Header, bool) {
		// 回滚区块链，确保我们不会得到一个无状态的头块。注意，允许深度相等以允许使用SetHead作为链修复机制而不删除任何数据！
		if currentBlock := bc.CurrentBlock(); currentBlock != nil && header.Number.Uint64() <= currentBlock.Number.Uint64() {
			newHeadBlock := bc.GetBlock(header.Hash(), header.Number.Uint64())
			if newHeadBlock == nil {
				log.Error("链中出现间隙，回滚到创世块", "number", header.Number, "hash", header.Hash())
				newHeadBlock = bc.genesisBlock
			} else {
				// 块存在，继续回滚，直到找到一个有状态的块
				// 继续回滚，直到超过可选的阈值根哈希
				beyondRoot := (root == common.Hash{}) // 标志是否超过了请求的根哈希（无根哈希，始终为true）

				for {
					// 如果请求了根哈希但尚未超过，进行检查
					if root != (common.Hash{}) && !beyondRoot && newHeadBlock.Root() == root {
						beyondRoot, rootNumber = true, newHeadBlock.NumberU64()
					}
					if !bc.HasState(newHeadBlock.Root()) {
						log.Trace("块状态丢失，继续回滚", "number", newHeadBlock.NumberU64(), "hash", newHeadBlock.Hash())
						if pivot == nil || newHeadBlock.NumberU64() > *pivot {
							parent := bc.GetBlock(newHeadBlock.ParentHash(), newHeadBlock.NumberU64()-1)
							if parent != nil {
								newHeadBlock = parent
								continue
							}
							log.Error("中间缺失块，目标是创世块", "number", newHeadBlock.NumberU64()-1, "hash", newHeadBlock.ParentHash())
							newHeadBlock = bc.genesisBlock
						} else {
							log.Trace("回滚超过枢轴，目标是创世块", "number", newHeadBlock.NumberU64(), "hash", newHeadBlock.Hash(), "pivot", *pivot)
							newHeadBlock = bc.genesisBlock
						}
					}
					if beyondRoot || newHeadBlock.NumberU64() == 0 {
						if newHeadBlock.NumberU64() == 0 {
							// 如果回滚目标是创世块且相关状态已丢失，则将创世状态重新提交到磁盘。将来，如果启用了历史链剪枝，此回滚目标可以是链中存储的最早的块。在这种情况下，此处的逻辑需要改进。
							if !bc.HasState(bc.genesisBlock.Root()) {
								if err := CommitGenesisState(bc.db, bc.triedb, bc.genesisBlock.Hash()); err != nil {
									log.Crit("提交创世状态失败", "err", err)
								}
								log.Debug("重新提交创世状态到磁盘")
							}
						}
						log.Debug("回滚到具有状态的块", "number", newHeadBlock.NumberU64(), "hash", newHeadBlock.Hash())
						break
					}
					log.Debug("跳过具有阈值状态的块", "number", newHeadBlock.NumberU64(), "hash", newHeadBlock.Hash(), "root", newHeadBlock.Root())
					newHeadBlock = bc.GetBlock(newHeadBlock.ParentHash(), newHeadBlock.NumberU64()-1) // 继续回滚
				}
			}
			rawdb.WriteHeadBlockHash(db, newHeadBlock.Hash())

			// 如果明确撤消了链标记，降级它们。理论上，我们应该在最后一步中更新所有内存中的标记，但是SetHead的方向是从高到低的，因此可以直接更新内存中的标记是安全的。
			bc.currentBlock.Store(newHeadBlock.Header())
			headBlockGauge.Update(int64(newHeadBlock.NumberU64()))
		}
		// 简单地将快速块回滚到目标头部
		if currentSnapBlock := bc.CurrentSnapBlock(); currentSnapBlock != nil && header.Number.Uint64() < currentSnapBlock.Number.Uint64() {
			newHeadSnapBlock := bc.GetBlock(header.Hash(), header.Number.Uint64())
			// 如果任一块为空，则重置为创世状态
			if newHeadSnapBlock == nil {
				newHeadSnapBlock = bc.genesisBlock
			}
			rawdb.WriteHeadFastBlockHash(db, newHeadSnapBlock.Hash())

			// 如果明确撤消了链标记，降级它们。理论上，我们应该在最后一步中更新所有内存中的标记，但是SetHead的方向是从高到低的，因此可以直接更新内存中的标记是安全的。
			bc.currentSnapBlock.Store(newHeadSnapBlock.Header())
			headFastBlockGauge.Update(int64(newHeadSnapBlock.NumberU64()))
		}
		var (
			headHeader = bc.CurrentBlock()
			headNumber = headHeader.Number.Uint64()
		)
		// 如果SetHead下溢了冷冻器阈值，并且之后的块处理意图是完整块导入，则删除从有状态块到sethead目标之间的链段。
		var wipe bool
		if headNumber+1 < frozen {
			wipe = pivot == nil || headNumber >= *pivot
		}
		return headHeader, wipe // 仅在完整同步时强制擦除
	}

    // 回滚头部链，删除直到指定块之前的所有块体
	delFn := func(db ethdb.KeyValueWriter, hash common.Hash, num uint64) {
		// 忽略此处的错误，因为轻客户端不会进入这个路径
		frozen, _ := bc.db.Ancients()
		if num+1 <= frozen {
			// 从古代存储中截断所有相关数据（头部、总难度、块体、收据和规范哈希）。
			if err := bc.db.TruncateHead(num); err != nil {
				log.Crit("截断古代数据失败", "块号", num, "错误", err)
			}
			// 从活跃存储中删除哈希 <-> 块号的映射关系。
			rawdb.DeleteHeaderNumber(db, hash)
		} else {
			// 从活跃存储中删除相关块体和收据。
			// 头部、总难度和规范哈希将在 hc.SetHead 函数中删除。
			rawdb.DeleteBody(db, hash, num)
			rawdb.DeleteReceipts(db, hash, num)
		}
		// 待办事项（rjl493456442）txlookup、bloombits 等
	}
	// 如果 SetHead 仅作为链修复方法调用，则尝试跳过整个头部链，除非冷冻器已损坏
	if repair {
		if target, force := updateFn(bc.db, bc.CurrentBlock()); force {
			bc.hc.SetHead(target.Number.Uint64(), updateFn, delFn)
		}
	} else {
		// 回滚链到指定的头部，并向后继续回滚，直到找到一个有状态的块或超过快速同步的枢轴
		if time > 0 {
			log.Warn("回滚区块链到时间戳", "目标", time)
			bc.hc.SetHeadWithTimestamp(time, updateFn, delFn)
		} else {
			log.Warn("回滚区块链到块", "目标", head)
			bc.hc.SetHead(head, updateFn, delFn)
		}
	}
	// 清除缓存中的任何过期内容
	bc.bodyCache.Purge()
	bc.bodyRLPCache.Purge()
	bc.receiptsCache.Purge()
	bc.blockCache.Purge()
	bc.txLookupCache.Purge()
	bc.futureBlocks.Purge()

	// 如果需要，清除安全块和最终块
	if safe := bc.CurrentSafeBlock(); safe != nil && head < safe.Number.Uint64() {
		log.Warn("SetHead 使安全块无效")
		bc.SetSafe(nil)
	}
	if finalized := bc.CurrentFinalBlock(); finalized != nil && head < finalized.Number.Uint64() {
		log.Error("SetHead 使最终块无效")
		bc.SetFinalized(nil)
	}
	return rootNumber, bc.loadLastState()
}
```































