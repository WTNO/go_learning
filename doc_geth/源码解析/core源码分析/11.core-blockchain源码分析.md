从测试案例来看,blockchain的主要功能点有下面几点.
1. import.
2. GetLastBlock的功能.
3. 如果有多条区块链,可以选取其中难度最大的一条作为规范的区块链.
4. BadHashes 可以手工禁止接受一些区块的hash值.在blocks.go里面.
5. 如果新配置了BadHashes. 那么区块启动的时候会自动禁止并进入有效状态.
6. 错误的nonce会被拒绝.
7. 支持Fast importing.
8. Light vs Fast vs Full processing 在处理区块头上面的效果相等.

可以看到blockchain的主要功能是维护区块链的状态, 包括区块的验证,插入和状态查询.

### 名词解释:
什么是规范的区块链？

因为在区块的创建过程中,可能在短时间内产生一些分叉, 在我们的数据库里面记录的其实是一颗区块树.我们会认为其中总难度最高的一条路径认为是我们的规范的区块链. 这样有很多区块虽然也能形成区块链,但是不是规范的区块链.

### 数据库结构(暂时没看懂)
```go
区块的hash值和区块头的hash值是同样的么。所谓的区块的Hash值其实就是Header的区块值。
// key -> value
// + 代表连接

"LastHeader"  最新的区块头 HeaderChain中使用
"LastBlock"   最新的区块头 BlockChain 中使用
"LastFast"    最新的快速同步的区块头

"h"+num+"n" -> hash  用来存储规范的区块链的高度和区块头的hash值

"h" + num + hash -> header 高度+hash值 -> 区块头

"h" + num + hash + "t" -> td  高度+hash值 -> 总难度

"H" + hash -> num  区块体hash -> 高度

"b" + num + hash -> block body   高度+hash值 -> 区块体

"r" + num + hash -> block receipts  高度 + hash值 -> 区块收据

"l" + hash -> transaction/receipt lookup metadata
```

|key | value|说明|插入|删除|
|---- | --- |---------------|-----------|-----------|
|"LastHeader" | hash | 最新的区块头 HeaderChain中使用|当区块被认为是当前最新的一个规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"LastBlock" |  hash | 最新的区块头 BlockChain中使用|当区块被认为是当前最新的一个规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"LastFast" | hash |  最新的区块头 BlockChain中使用|当区块被认为是当前最新的规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"h"+num+"n"|hash|用来存储规范的区块链的高度和区块头的hash值 在HeaderChain中使用|当区块在规范的区块链中|当区块不在规范的区块链中|
|"h" + num + hash + "t"|td|总难度|WriteBlockAndState当验证并执行完一个区块之后(不管是不是规范的)|SetHead方法会调用。这种方法只会在两种情况下被调用，1是当前区块链包含了badhashs，需要删除所有从badhashs开始的区块， 2.是当前区块的状态错误，需要Reset到genesis。|
|"H" + hash | num| 区块的高度 在HeaderChain中使用|WriteBlockAndState当验证并执行完一个区块之后|SetHead中被调用，同上|
|"b" + num + hash|block body| 区块数据| WriteBlockAndState or InsertReceiptChain|SetHead中被删除，同上|
|"r" + num + hash|block receipts|区块收据|WriteBlockAndState or InsertReceiptChain|同上|
|"l" + txHash | {hash,num,TxIndex|交易hash可以找到区块和交易|当区块加入规范的区块链|当区块从规范的区块链移除|

### 数据结构
```go
// BlockChain表示具有创世块的数据库中的规范链。Blockchain管理链的导入、回滚和链重组。
//
// 将块导入到区块链中是根据两阶段验证器定义的一组规则进行的。
// 块的处理是使用处理器进行的，处理其中包含的交易。
// 状态的验证是在验证器的第二部分中完成的。如果验证失败，则导入中止。
//
// BlockChain还有助于从数据库中包含的**任何**链返回块，以及代表规范链的块。
// 需要注意的是，GetBlock可以返回任何块，并不一定需要包含在规范链中，而GetBlockByNumber始终表示规范链。
type BlockChain struct {
	chainConfig *params.ChainConfig // 链和网络配置
	cacheConfig *CacheConfig        // 剪枝的缓存配置

	db            ethdb.Database                   // 用于存储最终内容的底层持久性数据库
	snaps         *snapshot.Tree                   // 用于快速trie叶子访问的快照树
	triegc        *prque.Prque[int64, common.Hash] // 将块号映射到要进行垃圾回收的tries的优先级队列
	gcproc        time.Duration                    // 积累规范块处理以进行trie转储
	lastWrite     uint64                           // 状态刷新时的最后一个块
	flushInterval atomic.Int64                     // 在此之后刷新状态的时间间隔（处理时间）
	triedb        *trie.Database                   // 用于维护trie节点的数据库处理程序。
	stateCache    state.Database                   // 在导入之间重用的状态数据库（包含状态缓存）

	// txLookupLimit是保留事务索引的从头部开始的最大块数：
	//  * 0:   表示没有限制，并重新生成任何丢失的索引
	//  * N:   表示N个块的限制[HEAD-N+1, HEAD]并删除额外的索引
	//  * nil: 禁用tx重新索引器/删除器，但仍然索引新的块
	txLookupLimit uint64

	hc            *HeaderChain
	rmLogsFeed    event.Feed
	chainFeed     event.Feed
	chainSideFeed event.Feed
	chainHeadFeed event.Feed
	logsFeed      event.Feed
	blockProcFeed event.Feed
	scope         event.SubscriptionScope
	genesisBlock  *types.Block

	// 此互斥锁同步链写操作。
	// 读者不需要获取它，只需读取数据库即可。
	chainmu *syncx.ClosableMutex

	currentBlock      atomic.Pointer[types.Header] // 链的当前头
	currentSnapBlock  atomic.Pointer[types.Header] // 当前快照同步的头
	currentFinalBlock atomic.Pointer[types.Header] // 最新（共识）的已最终化块
	currentSafeBlock  atomic.Pointer[types.Header] // 最新（共识）的安全块

	bodyCache     *lru.Cache[common.Hash, *types.Body]
	bodyRLPCache  *lru.Cache[common.Hash, rlp.RawValue]
	receiptsCache *lru.Cache[common.Hash, []*types.Receipt]
	blockCache    *lru.Cache[common.Hash, *types.Block]
	txLookupCache *lru.Cache[common.Hash, *rawdb.LegacyTxLookupEntry]

	// 未来块是添加以供稍后处理的块
	futureBlocks *lru.Cache[common.Hash, *types.Block]

	wg            sync.WaitGroup //
	quit          chan struct{}  // 关闭信号，在Stop中关闭。
	stopping      atomic.Bool    // 如果链正在运行，则为false，如果停止，则为true
	procInterrupt atomic.Bool    // 用于块处理的中断信号

	engine     consensus.Engine
	validator  Validator // 块和状态验证器接口
	prefetcher Prefetcher
	processor  Processor // 块事务处理器接口
	forker     *ForkChoice
	vmConfig   vm.Config
}
```

### 构造方法NewBlockChain
使用数据库里面的可用信息构造了一个初始化好的区块链. 同时初始化了以太坊默认的 验证器和处理器 (Validator and Processor)
```go
// NewBlockChain 返回一个完全初始化的区块链，使用数据库中可用的信息。
// 它初始化了默认的以太坊验证器和处理器。
func NewBlockChain(db ethdb.Database, cacheConfig *CacheConfig, genesis *Genesis, overrides *ChainOverrides, engine consensus.Engine, vmConfig vm.Config, shouldPreserve func(header *types.Header) bool, txLookupLimit *uint64) (*BlockChain, error) {
	if cacheConfig == nil {
		cacheConfig = defaultCacheConfig
	}
	// 使用提供的配置打开 trie 数据库
	triedb := trie.NewDatabaseWithConfig(db, &trie.Config{
		Cache:     cacheConfig.TrieCleanLimit,
		Journal:   cacheConfig.TrieCleanJournal,
		Preimages: cacheConfig.Preimages,
	})
	// 设置创世块，如果创世块尚不存在，则将提供的创世规范提交到数据库中，否则从数据库中加载已存储的创世块。
	chainConfig, genesisHash, genesisErr := SetupGenesisBlockWithOverride(db, triedb, genesis, overrides)
	if _, ok := genesisErr.(*params.ConfigCompatError); genesisErr != nil && !ok {
		return nil, genesisErr
	}
	log.Info("")
	log.Info(strings.Repeat("-", 153))
	for _, line := range strings.Split(chainConfig.Description(), "\n") {
		log.Info(line)
	}
	log.Info(strings.Repeat("-", 153))
	log.Info("")

	bc := &BlockChain{
		chainConfig:   chainConfig,
		cacheConfig:   cacheConfig,
		db:            db,
		triedb:        triedb,
		triegc:        prque.New[int64, common.Hash](nil),
		quit:          make(chan struct{}),
		chainmu:       syncx.NewClosableMutex(),
		bodyCache:     lru.NewCache[common.Hash, *types.Body](bodyCacheLimit),
		bodyRLPCache:  lru.NewCache[common.Hash, rlp.RawValue](bodyCacheLimit),
		receiptsCache: lru.NewCache[common.Hash, []*types.Receipt](receiptsCacheLimit),
		blockCache:    lru.NewCache[common.Hash, *types.Block](blockCacheLimit),
		txLookupCache: lru.NewCache[common.Hash, *rawdb.LegacyTxLookupEntry](txLookupCacheLimit),
		futureBlocks:  lru.NewCache[common.Hash, *types.Block](maxFutureBlocks),
		engine:        engine,
		vmConfig:      vmConfig,
	}
	bc.flushInterval.Store(int64(cacheConfig.TrieTimeLimit))
	bc.forker = NewForkChoice(bc, shouldPreserve)
	bc.stateCache = state.NewDatabaseWithNodeDB(bc.db, bc.triedb)
	bc.validator = NewBlockValidator(chainConfig, bc, engine)
	bc.prefetcher = newStatePrefetcher(chainConfig, bc, engine)
	bc.processor = NewStateProcessor(chainConfig, bc, engine)

	var err error
	bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.insertStopped)
	if err != nil {
		return nil, err
	}
	bc.genesisBlock = bc.GetBlockByNumber(0)
	if bc.genesisBlock == nil {
		return nil, ErrNoGenesis
	}

	bc.currentBlock.Store(nil)
	bc.currentSnapBlock.Store(nil)
	bc.currentFinalBlock.Store(nil)
	bc.currentSafeBlock.Store(nil)

	// 如果 Geth 初始化时使用外部古代存储，则重新初始化丢失的链索引和链标志。
	// 这个过程可以在崩溃后继续进行，并且可以在下一次重启中恢复，因为链标志在最后一步中更新。
	if bc.empty() {
		rawdb.InitDatabaseFromFreezer(bc.db)
	}
	// 从磁盘加载区块链状态
	if err := bc.loadLastState(); err != nil {
		return nil, err
	}
	// 确保与块关联的状态可用
	head := bc.CurrentBlock()
	if !bc.HasState(head.Root) {
		// 头状态丢失，在进行状态恢复之前，找出快照的磁盘层点（如果启用了快照）。
		// 确保回绕点低于磁盘层。
		var diskRoot common.Hash
		if bc.cacheConfig.SnapshotLimit > 0 {
			diskRoot = rawdb.ReadSnapshotRoot(bc.db)
		}
		if diskRoot != (common.Hash{}) {
			log.Warn("头状态丢失，修复中", "number", head.Number, "hash", head.Hash(), "snaproot", diskRoot)

			snapDisk, err := bc.setHeadBeyondRoot(head.Number.Uint64(), 0, diskRoot, true)
			if err != nil {
				return nil, err
			}
			// 链回绕，将旧快照号持久化以指示恢复过程
			if snapDisk != 0 {
				rawdb.WriteSnapshotRecoveryNumber(bc.db, snapDisk)
			}
		} else {
			log.Warn("头状态丢失，修复中", "number", head.Number, "hash", head.Hash())
			if _, err := bc.setHeadBeyondRoot(head.Number.Uint64(), 0, common.Hash{}, true); err != nil {
				return nil, err
			}
		}
	}
	// 确保 SetHead 中的上一次崩溃不会留下额外的古代块
	if frozen, err := bc.db.Ancients(); err == nil && frozen > 0 {
		var (
			needRewind bool
			low        uint64
		)
		// 由于区块链修复，完整块可能会回滚到非常低的高度。
		// 如果完整块甚至低于古代链，截断古代存储。
		fullBlock := bc.CurrentBlock()
		if fullBlock != nil && fullBlock.Hash() != bc.genesisBlock.Hash() && fullBlock.Number.Uint64() < frozen-1 {
			needRewind = true
			low = fullBlock.Number.Uint64()
		}
		// 在快速同步中，可能已将古代数据写入古代存储，但 LastFastBlock 尚未更新，此处截断额外数据。
		snapBlock := bc.CurrentSnapBlock()
		if snapBlock != nil && snapBlock.Number.Uint64() < frozen-1 {
			needRewind = true
			if snapBlock.Number.Uint64() < low || low == 0 {
				low = snapBlock.Number.Uint64()
			}
		}
		if needRewind {
			log.Error("截断古代链", "from", bc.CurrentHeader().Number.Uint64(), "to", low)
			if err := bc.SetHead(low); err != nil {
				return nil, err
			}
		}
	}
	// 节点的第一件事是重建头块的验证数据（ethash 缓存或 clique 投票快照），最好提前做。
	bc.engine.VerifyHeader(bc, bc.CurrentHeader())

	// 检查块哈希的当前状态，并确保我们的链中没有任何坏块
	for hash := range BadHashes {
		if header := bc.GetHeaderByHash(hash); header != nil {
			// 获取与有问题的头部的数字对应的规范块
			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())
			// 确保 headerByNumber（如果存在）在当前的规
            if headerByNumber != nil && headerByNumber.Hash() == header.Hash() {
                log.Error("Found bad hash, rewinding chain", "number", header.Number, "hash", header.ParentHash)
                if err := bc.SetHead(header.Number.Uint64() - 1); err != nil {
                    return nil, err
                }
                log.Error("Chain rewind was successful, resuming normal operation")
			}
		}
    }
    // 加载任何现有的快照，如果加载失败则重新生成
    if bc.cacheConfig.SnapshotLimit > 0 {
        // 如果链被回滚到快照持久层（导致恢复块号被持久化到磁盘），检查是否仍处于恢复模式，
		// 如果是，则在头不匹配的情况下不使快照失效。
        var recover bool
        
        head := bc.CurrentBlock()
        if layer := rawdb.ReadSnapshotRecoveryNumber(bc.db); layer != nil && *layer >= head.Number.Uint64() {
            log.Warn("启用快照恢复", "链头", head.Number, "磁盘基础", *layer)
            recover = true
        }
        snapconfig := snapshot.Config{
            CacheSize:  bc.cacheConfig.SnapshotLimit,
            Recovery:   recover,
            NoBuild:    bc.cacheConfig.SnapshotNoBuild,
            AsyncBuild: !bc.cacheConfig.SnapshotWait,
        }
        bc.snaps, _ = snapshot.New(snapconfig, bc.db, bc.triedb, head.Root)
    }
    
    // 启动未来区块处理器。
    bc.wg.Add(1)
    go bc.updateFutureBlocks()
    
    // 如果需要定期清理缓存日志，启动它。
    if bc.cacheConfig.TrieCleanRejournal > 0 {
        if bc.cacheConfig.TrieCleanRejournal < time.Minute {
            log.Warn("清理无效的Trie缓存日志时间", "提供的", bc.cacheConfig.TrieCleanRejournal, "更新为", time.Minute)
            bc.cacheConfig.TrieCleanRejournal = time.Minute
        }
        bc.wg.Add(1)
        go func() {
            defer bc.wg.Done()
            bc.triedb.SaveCachePeriodically(bc.cacheConfig.TrieCleanJournal, bc.cacheConfig.TrieCleanRejournal, bc.quit)
        }()
    }
    // 在不兼容的配置升级的情况下回滚链。
    if compat, ok := genesisErr.(*params.ConfigCompatError); ok {
        log.Warn("回滚链以升级配置", "错误", compat)
        if compat.RewindToTime > 0 {
            bc.SetHeadWithTimestamp(compat.RewindToTime)
        } else {
            bc.SetHead(compat.RewindToBlock)
        }
        rawdb.WriteChainConfig(db, genesisHash, chainConfig)
    }
    // 如果需要，启动交易索引器/反索引器。
    if txLookupLimit != nil {
        bc.txLookupLimit = *txLookupLimit
        
        bc.wg.Add(1)
        go bc.maintainTxIndex()
    }
    return bc, nil
}
```

### loadLastState
加载数据库里面的最新的我们知道的区块链状态. 这个方法假设已经获取到锁了.
```go
// loadLastState从数据库加载最后已知的链状态。该方法假设链管理器的互斥锁已经被持有。
func (bc *BlockChain) loadLastState() error {
	// 恢复最后已知的头块
	head := rawdb.ReadHeadBlockHash(bc.db)
	if head == (common.Hash{}) {
		// 数据库损坏或为空，从头开始初始化
		log.Warn("数据库为空，重置链")
		return bc.Reset()
	}
	// 确保整个头块可用
	headBlock := bc.GetBlockByHash(head)
	if headBlock == nil {
		// 数据库损坏或为空，从头开始初始化
		log.Warn("头块丢失，重置链", "hash", head)
		return bc.Reset()
	}
	// 一切似乎都正常，设置为头块
	bc.currentBlock.Store(headBlock.Header())
	headBlockGauge.Update(int64(headBlock.NumberU64()))

	// 恢复最后已知的头头部
	headHeader := headBlock.Header()
	if head := rawdb.ReadHeadHeaderHash(bc.db); head != (common.Hash{}) {
		if header := bc.GetHeaderByHash(head); header != nil {
			headHeader = header
		}
	}
	bc.hc.SetCurrentHeader(headHeader)

	// 恢复最后已知的快照块
	bc.currentSnapBlock.Store(headBlock.Header())
	headFastBlockGauge.Update(int64(headBlock.NumberU64()))

	if head := rawdb.ReadHeadFastBlockHash(bc.db); head != (common.Hash{}) {
		if block := bc.GetBlockByHash(head); block != nil {
			bc.currentSnapBlock.Store(block.Header())
			headFastBlockGauge.Update(int64(block.NumberU64()))
		}
	}

	// 恢复最后已知的最终块和安全块
	// 注意：安全块未存储在磁盘上，并在启动时设置为最后已知的最终块
	if head := rawdb.ReadFinalizedBlockHash(bc.db); head != (common.Hash{}) {
		if block := bc.GetBlockByHash(head); block != nil {
			bc.currentFinalBlock.Store(block.Header())
			headFinalizedBlockGauge.Update(int64(block.NumberU64()))
			bc.currentSafeBlock.Store(block.Header())
			headSafeBlockGauge.Update(int64(block.NumberU64()))
		}
	}
	// 向用户发出状态日志
	var (
		currentSnapBlock  = bc.CurrentSnapBlock()
		currentFinalBlock = bc.CurrentFinalBlock()

		headerTd = bc.GetTd(headHeader.Hash(), headHeader.Number.Uint64())
		blockTd  = bc.GetTd(headBlock.Hash(), headBlock.NumberU64())
	)
	if headHeader.Hash() != headBlock.Hash() {
		log.Info("加载最近的本地头部", "number", headHeader.Number, "hash", headHeader.Hash(), "td", headerTd, "age", common.PrettyAge(time.Unix(int64(headHeader.Time), 0)))
	}
	log.Info("加载最近的本地块", "number", headBlock.Number(), "hash", headBlock.Hash(), "td", blockTd, "age", common.PrettyAge(time.Unix(int64(headBlock.Time()), 0)))
	if headBlock.Hash() != currentSnapBlock.Hash() {
		fastTd := bc.GetTd(currentSnapBlock.Hash(), currentSnapBlock.Number.Uint64())
		log.Info("加载最近的本地快照块", "number", currentSnapBlock.Number, "hash", currentSnapBlock.Hash(), "td", fastTd, "age", common.PrettyAge(time.Unix(int64(currentSnapBlock.Time), 0)))
	}
	if currentFinalBlock != nil {
		finalTd := bc.GetTd(currentFinalBlock.Hash(), currentFinalBlock.Number.Uint64())
		log.Info("加载最近的本地最终块", "number", currentFinalBlock.Number, "hash", currentFinalBlock.Hash(), "td", finalTd, "age", common.PrettyAge(time.Unix(int64(currentFinalBlock.Time), 0)))
	}
	if pivot := rawdb.ReadLastPivotNumber(bc.db); pivot != nil {
		log.Info("加载最后的快速同步轴标记", "number", *pivot)
	}
	return nil
}
```

### updateFutureBlocks
goroutine update的处理非常简单. 定时处理future blocks.
```go
func (bc *BlockChain) updateFutureBlocks() {
	futureTimer := time.NewTicker(5 * time.Second)
	defer futureTimer.Stop()
	defer bc.wg.Done()
	for {
		select {
		case <-futureTimer.C:
			bc.procFutureBlocks()
		case <-bc.quit:
			return
		}
	}
}
```

### Reset
重置区块链.
```go
// Reset函数将整个区块链重置为创世状态。
func (bc *BlockChain) Reset() error {
	return bc.ResetWithGenesisBlock(bc.genesisBlock)
}

// ResetWithGenesisBlock函数将整个区块链重置为指定的创世状态。
func (bc *BlockChain) ResetWithGenesisBlock(genesis *types.Block) error {
	// 清空整个区块链并清除缓存
	if err := bc.SetHead(0); err != nil {
		return err
	}
	if !bc.chainmu.TryLock() {
		return errChainStopped
	}
	defer bc.chainmu.Unlock()

	// 准备创世块并重新初始化链
	batch := bc.db.NewBatch()
	rawdb.WriteTd(batch, genesis.Hash(), genesis.NumberU64(), genesis.Difficulty())
	rawdb.WriteBlock(batch, genesis)
	if err := batch.Write(); err != nil {
		log.Crit("写入创世块失败", "err", err)
	}
	bc.writeHeadBlock(genesis)

	// 最后更新所有内存中的链标记
	bc.genesisBlock = genesis
	bc.currentBlock.Store(bc.genesisBlock.Header())
	headBlockGauge.Update(int64(bc.genesisBlock.NumberU64()))
	bc.hc.SetGenesis(bc.genesisBlock.Header())
	bc.hc.SetCurrentHeader(bc.genesisBlock.Header())
	bc.currentSnapBlock.Store(bc.genesisBlock.Header())
	headFastBlockGauge.Update(int64(bc.genesisBlock.NumberU64()))
	return nil
}
```

### SetHead
将本地链回卷到新的头部。 在给定新header之上的所有内容都将被删除，新的header将被设置。 如果块体丢失（快速同步之后的非归档节点），头部可能被进一步倒回。
```go
// SetHead方法将本地链重置到一个新的头部。根据节点是快速同步还是完全同步，以及处于哪个状态，该方法将尝试在保持链一致性的同时尽可能删除最小的磁盘数据。
func (bc *BlockChain) SetHead(head uint64) error {
	if _, err := bc.setHeadBeyondRoot(head, 0, common.Hash{}, false); err != nil {
		return err
	}
	// 发送链头事件以更新交易池
	header := bc.CurrentBlock()
	block := bc.GetBlock(header.Hash(), header.Number.Uint64())
	if block == nil {
		// 这应该不会发生。实际上，先前的currentBlock包含整个块，而现在只有一个“标记”，所以有极低的竞争机会，我们应该处理。
		log.Error("数据库中找不到当前块", "块", header.Number, "哈希", header.Hash())
		return fmt.Errorf("当前块丢失：#%d [%x..]", header.Number, header.Hash().Bytes()[:4])
	}
	bc.chainHeadFeed.Send(ChainHeadEvent{Block: block})
	return nil
}
```

#### setHeadBeyondRoot
```go
// setHeadBeyondRoot方法将本地链重置为具有额外条件的新头部，该条件是重置必须通过指定的状态根。此方法旨在在启用快照的情况下使用，以确保我们回退的更远，而不是持久磁盘层。根据节点是快速同步还是完整同步以及处于哪个状态，该方法将尝试从磁盘中删除最少的数据，同时保持链的一致性。

// 如果`head == 0`但`time != 0`，该方法也可以在时间戳模式下工作。在这种情况下，块将回滚，直到新头部变得早于或等于请求的时间。如果`head`和`time`都为0，则链将回滚到创世块。

// 该方法返回找到请求的根哈希的块号。

func (bc *BlockChain) setHeadBeyondRoot(head uint64, time uint64, root common.Hash, repair bool) (uint64, error) {
	if !bc.chainmu.TryLock() {
		return 0, errChainStopped
	}
	defer bc.chainmu.Unlock()

	// 跟踪请求的根哈希的块号
	var rootNumber uint64 //（无根哈希 == 始终为0）

	// 检索上一个枢轴块以绕过它和当前冷冻器限制以开始删除已下溢的id
	pivot := rawdb.ReadLastPivotNumber(bc.db)
	frozen, _ := bc.db.Ancients()

	updateFn := func(db ethdb.KeyValueWriter, header *types.Header) (*types.Header, bool) {
		// 回滚区块链，确保我们不会得到一个无状态的头块。注意，允许深度相等以允许使用SetHead作为链修复机制而不删除任何数据！
		if currentBlock := bc.CurrentBlock(); currentBlock != nil && header.Number.Uint64() <= currentBlock.Number.Uint64() {
			newHeadBlock := bc.GetBlock(header.Hash(), header.Number.Uint64())
			if newHeadBlock == nil {
				log.Error("链中出现间隙，回滚到创世块", "number", header.Number, "hash", header.Hash())
				newHeadBlock = bc.genesisBlock
			} else {
				// 块存在，继续回滚，直到找到一个有状态的块
				// 继续回滚，直到超过可选的阈值根哈希
				beyondRoot := (root == common.Hash{}) // 标志是否超过了请求的根哈希（无根哈希，始终为true）

				for {
					// 如果请求了根哈希但尚未超过，进行检查
					if root != (common.Hash{}) && !beyondRoot && newHeadBlock.Root() == root {
						beyondRoot, rootNumber = true, newHeadBlock.NumberU64()
					}
					if !bc.HasState(newHeadBlock.Root()) {
						log.Trace("块状态丢失，继续回滚", "number", newHeadBlock.NumberU64(), "hash", newHeadBlock.Hash())
						if pivot == nil || newHeadBlock.NumberU64() > *pivot {
							parent := bc.GetBlock(newHeadBlock.ParentHash(), newHeadBlock.NumberU64()-1)
							if parent != nil {
								newHeadBlock = parent
								continue
							}
							log.Error("中间缺失块，目标是创世块", "number", newHeadBlock.NumberU64()-1, "hash", newHeadBlock.ParentHash())
							newHeadBlock = bc.genesisBlock
						} else {
							log.Trace("回滚超过枢轴，目标是创世块", "number", newHeadBlock.NumberU64(), "hash", newHeadBlock.Hash(), "pivot", *pivot)
							newHeadBlock = bc.genesisBlock
						}
					}
					if beyondRoot || newHeadBlock.NumberU64() == 0 {
						if newHeadBlock.NumberU64() == 0 {
							// 如果回滚目标是创世块且相关状态已丢失，则将创世状态重新提交到磁盘。将来，如果启用了历史链剪枝，此回滚目标可以是链中存储的最早的块。在这种情况下，此处的逻辑需要改进。
							if !bc.HasState(bc.genesisBlock.Root()) {
								if err := CommitGenesisState(bc.db, bc.triedb, bc.genesisBlock.Hash()); err != nil {
									log.Crit("提交创世状态失败", "err", err)
								}
								log.Debug("重新提交创世状态到磁盘")
							}
						}
						log.Debug("回滚到具有状态的块", "number", newHeadBlock.NumberU64(), "hash", newHeadBlock.Hash())
						break
					}
					log.Debug("跳过具有阈值状态的块", "number", newHeadBlock.NumberU64(), "hash", newHeadBlock.Hash(), "root", newHeadBlock.Root())
					newHeadBlock = bc.GetBlock(newHeadBlock.ParentHash(), newHeadBlock.NumberU64()-1) // 继续回滚
				}
			}
			rawdb.WriteHeadBlockHash(db, newHeadBlock.Hash())

			// 如果明确撤消了链标记，降级它们。理论上，我们应该在最后一步中更新所有内存中的标记，但是SetHead的方向是从高到低的，因此可以直接更新内存中的标记是安全的。
			bc.currentBlock.Store(newHeadBlock.Header())
			headBlockGauge.Update(int64(newHeadBlock.NumberU64()))
		}
		// 简单地将快速块回滚到目标头部
		if currentSnapBlock := bc.CurrentSnapBlock(); currentSnapBlock != nil && header.Number.Uint64() < currentSnapBlock.Number.Uint64() {
			newHeadSnapBlock := bc.GetBlock(header.Hash(), header.Number.Uint64())
			// 如果任一块为空，则重置为创世状态
			if newHeadSnapBlock == nil {
				newHeadSnapBlock = bc.genesisBlock
			}
			rawdb.WriteHeadFastBlockHash(db, newHeadSnapBlock.Hash())

			// 如果明确撤消了链标记，降级它们。理论上，我们应该在最后一步中更新所有内存中的标记，但是SetHead的方向是从高到低的，因此可以直接更新内存中的标记是安全的。
			bc.currentSnapBlock.Store(newHeadSnapBlock.Header())
			headFastBlockGauge.Update(int64(newHeadSnapBlock.NumberU64()))
		}
		var (
			headHeader = bc.CurrentBlock()
			headNumber = headHeader.Number.Uint64()
		)
		// 如果SetHead下溢了冷冻器阈值，并且之后的块处理意图是完整块导入，则删除从有状态块到sethead目标之间的链段。
		var wipe bool
		if headNumber+1 < frozen {
			wipe = pivot == nil || headNumber >= *pivot
		}
		return headHeader, wipe // 仅在完整同步时强制擦除
	}

    // 回滚头部链，删除直到指定块之前的所有块体
	delFn := func(db ethdb.KeyValueWriter, hash common.Hash, num uint64) {
		// 忽略此处的错误，因为轻客户端不会进入这个路径
		frozen, _ := bc.db.Ancients()
		if num+1 <= frozen {
			// 从古代存储中截断所有相关数据（头部、总难度、块体、收据和规范哈希）。
			if err := bc.db.TruncateHead(num); err != nil {
				log.Crit("截断古代数据失败", "块号", num, "错误", err)
			}
			// 从活跃存储中删除哈希 <-> 块号的映射关系。
			rawdb.DeleteHeaderNumber(db, hash)
		} else {
			// 从活跃存储中删除相关块体和收据。
			// 头部、总难度和规范哈希将在 hc.SetHead 函数中删除。
			rawdb.DeleteBody(db, hash, num)
			rawdb.DeleteReceipts(db, hash, num)
		}
		// 待办事项（rjl493456442）txlookup、bloombits 等
	}
	// 如果 SetHead 仅作为链修复方法调用，则尝试跳过整个头部链，除非冷冻器已损坏
	if repair {
		if target, force := updateFn(bc.db, bc.CurrentBlock()); force {
			bc.hc.SetHead(target.Number.Uint64(), updateFn, delFn)
		}
	} else {
		// 回滚链到指定的头部，并向后继续回滚，直到找到一个有状态的块或超过快速同步的枢轴
		if time > 0 {
			log.Warn("回滚区块链到时间戳", "目标", time)
			bc.hc.SetHeadWithTimestamp(time, updateFn, delFn)
		} else {
			log.Warn("回滚区块链到块", "目标", head)
			bc.hc.SetHead(head, updateFn, delFn)
		}
	}
	// 清除缓存中的任何过期内容
	bc.bodyCache.Purge()
	bc.bodyRLPCache.Purge()
	bc.receiptsCache.Purge()
	bc.blockCache.Purge()
	bc.txLookupCache.Purge()
	bc.futureBlocks.Purge()

	// 如果需要，清除安全块和最终块
	if safe := bc.CurrentSafeBlock(); safe != nil && head < safe.Number.Uint64() {
		log.Warn("SetHead 使安全块无效")
		bc.SetSafe(nil)
	}
	if finalized := bc.CurrentFinalBlock(); finalized != nil && head < finalized.Number.Uint64() {
		log.Error("SetHead 使最终块无效")
		bc.SetFinalized(nil)
	}
	return rootNumber, bc.loadLastState()
}
```

### InsertChain
插入区块链, 插入区块链尝试把给定的区块插入到规范的链条,或者是创建一个分叉. 如果发生错误,那么会返回错误发生时候的index和具体的错误信息.
```go
// InsertChain尝试将给定的一批块插入到规范链中，或者创建一个分叉。如果返回错误，它将返回失败块的索引号以及描述出错原因的错误。插入完成后，将触发所有累积的事件。
func (bc *BlockChain) InsertChain(chain types.Blocks) (int, error) {
	// 检查我们是否有有意义的内容可导入
	if len(chain) == 0 {
		return 0, nil
	}
	bc.blockProcFeed.Send(true)
	defer bc.blockProcFeed.Send(false)

	// 对提供的链进行顺序和链接的合法性检查。
	for i := 1; i < len(chain); i++ {
		block, prev := chain[i], chain[i-1]
		if block.NumberU64() != prev.NumberU64()+1 || block.ParentHash() != prev.Hash() {
			log.Error("非连续的块插入",
				"number", block.Number(),
				"hash", block.Hash(),
				"parent", block.ParentHash(),
				"prevnumber", prev.Number(),
				"prevhash", prev.Hash(),
			)
			return 0, fmt.Errorf("非连续的插入：第%d个块是第%d个块[%x..]，第%d个块是第%d个块[%x..]（父块[%x..]）", i-1, prev.NumberU64(),
				prev.Hash().Bytes()[:4], i, block.NumberU64(), block.Hash().Bytes()[:4], block.ParentHash().Bytes()[:4])
		}
	}
	// 前置检查通过，开始完整的块导入
	if !bc.chainmu.TryLock() {
		return 0, errChainStopped
	}
	defer bc.chainmu.Unlock()
	return bc.insertChain(chain, true)
}
```

### InsertChain
插入区块链，插入区块链尝试把给定的区块插入到规范的链条，或者是创建一个分叉. 如果发生错误，那么会返回错误发生时候的index和具体的错误信息
```go
// insertChain是InsertChain的内部实现，假设
// 1）链是连续的，2）链的互斥锁已经持有。
//
// 将此方法拆分出来，以便需要重新注入历史块的导入批次可以在不释放锁的情况下执行，这可能会导致竞态行为。如果正在进行侧链导入，并且已导入历史状态，但在实际侧链完成之前添加了新的主链头，则历史状态可能再次被删除。
func (bc *BlockChain) insertChain(chain types.Blocks, setHead bool) (int, error) {
	// 如果链正在终止，甚至不要开始。
	if bc.insertStopped() {
		return 0, nil
	}

	// 启动并行签名恢复（签名者将在分叉转换时出错，性能损失最小）
	SenderCacher.RecoverFromBlocks(types.MakeSigner(bc.chainConfig, chain[0].Number(), chain[0].Time()), chain)

	var (
		stats     = insertStats{startTime: mclock.Now()}
		lastCanon *types.Block
	)
	// 如果我们推进了链，触发一个链头事件
	defer func() {
		if lastCanon != nil && bc.CurrentBlock().Hash() == lastCanon.Hash() {
			bc.chainHeadFeed.Send(ChainHeadEvent{lastCanon})
		}
	}()
	// 启动并行头部验证器
	headers := make([]*types.Header, len(chain))
	for i, block := range chain {
		headers[i] = block.Header()
	}
	abort, results := bc.engine.VerifyHeaders(bc, headers)
	defer close(abort)

	// 查看第一个块的错误以决定导入逻辑的方向
	it := newInsertIterator(chain, results, bc.validator)
	block, err := it.next()

	// 左修剪所有已知的块，不需要构建快照
	if bc.skipBlock(err, it) {
		// 第一个块（和状态）已知
		//   1. 我们进行了回滚，现在应该重新导入
		//   2. 块存储为侧链，并且关于其状态根有欺骗，通过了一个来自尚未验证的主链的状态根。
		// 跳过我们后面的所有已知块。
		var (
			reorg   bool
			current = bc.CurrentBlock()
		)
		for block != nil && bc.skipBlock(err, it) {
			reorg, err = bc.forker.ReorgNeeded(current, block.Header())
			if err != nil {
				return it.index, err
			}
			if reorg {
				// 如果forker说reorg是必要的，并且块不在规范链上，切换到导入模式。
				// 在eth2中，forker对于reorg决策总是返回true（盲目信任外部共识引擎），
				// 但为了防止在导入已知块时发生不必要的reorg，此处处理了特殊情况。
				if block.NumberU64() > current.Number.Uint64() || bc.GetCanonicalHash(block.NumberU64()) != block.Hash() {
					break
				}
			}
			log.Debug("忽略已知块", "编号", block.Number(), "哈希", block.Hash())
			stats.ignored++

			block, err = it.next()
		}
		// 剩下的块仍然是已知块，这里唯一的情况是：
		// 在快速同步期间，枢轴点已经提交，但发生了回滚。
		// 然后，节点通过`rollback`将头完整块重置为较低的高度，
		// 并在数据库中留下了一些已知块。
		//
		// 当节点再次运行快速同步时，它可以通过`insertChain`重新导入一批已知块，
		// 而其中一部分的总难度比当前头完整块（新的枢轴点）高。
		for block != nil && bc.skipBlock(err, it) {
			log.Debug("写入先前已知块", "编号", block.Number(), "哈希", block.Hash())
			if err := bc.writeKnownBlock(block); err != nil {
				return it.index, err
			}
			lastCanon = block

			block, err = it.next()
		}
		// 进入块导入
	}
	switch {
	// 第一个块被修剪
	case errors.Is(err, consensus.ErrPrunedAncestor):
		if setHead {
			// 第一个块被修剪，作为侧链插入，只有当TD足够增长时才进行重组
			log.Debug("修剪的祖先，插入为侧链", "编号", block.Number(), "哈希", block.Hash())
			return bc.insertSideChain(block, it)
		} else {
			// 我们已经合并，并且父块被修剪，尝试恢复父状态
			log.Debug("修剪的祖先", "编号", block.Number(), "哈希", block.Hash())
			_, err := bc.recoverAncestors(block)
			return it.index, err
		}
	// 第一个块是未来的，将其（和所有子块）推到未来队列中（未知祖先）
	case errors.Is(err, consensus.ErrFutureBlock) || (errors.Is(err, consensus.ErrUnknownAncestor) && bc.futureBlocks.Contains(it.first().ParentHash())):
		for block != nil && (it.index == 0 || errors.Is(err, consensus.ErrUnknownAncestor)) {
			log.Debug("未来块，推迟导入", "编号", block.Number(), "哈希", block.Hash())
			if err := bc.addFutureBlock(block); err != nil {
				return it.index, err
			}
			block, err = it.next()
		}
		stats.queued += it.processed()
		stats.ignored += it.remaining()

		// 如果还有剩下的块，标记为被忽略
		return it.index, err

	// 发生其他错误（除了ErrKnownBlock），中止。
	// 允许ErrKnownBlock是因为一些已知块仍然需要重新执行以生成丢失的快照
	case err != nil && !errors.Is(err, ErrKnownBlock):
		bc.futureBlocks.Remove(block.Hash())
		stats.ignored += len(it.chain)
		bc.reportBlock(block, nil, err)
		return it.index, err
	}
	// 第一个块没有验证错误（或者链前缀被跳过）
	var activeState *state.StateDB
	defer func() {
		// 链导入器正在启动和停止trie预取器。然而，如果遇到坏块或其他错误，早期返回可能无法正确终止后台线程。此延迟确保我们清理悬空的预取器，而不是每个都延迟并保持活动引用。
		if activeState != nil {
			activeState.StopPrefetcher()
		}
	}()

    for ; block != nil && err == nil || errors.Is(err, ErrKnownBlock); block, err = it.next() {
    	// 如果链正在终止，则停止处理区块
    	if bc.insertStopped() {
    		log.Debug("在区块处理过程中中止")
    		break
    	}
    	// 如果区块的头部是被禁止的，则直接中止
    	if BadHashes[block.Hash()] {
    		bc.reportBlock(block, nil, ErrBannedHash)
    		return it.index, ErrBannedHash
    	}
    	// 如果区块已知（在链的中间），这是 Clique 区块的特殊情况，它们可以在彼此之间共享状态，
    	// 因此导入一个较旧的区块可能会完善后续区块的状态。在这种情况下，只需跳过该区块
    	// （我们已经完全验证过一次（并且崩溃了），因为它的头部和主体已经在数据库中）。但是，
    	// 如果对应的快照层缺失，强制重新执行以构建它。
    	if bc.skipBlock(err, it) {
    		logger := log.Debug
    		if bc.chainConfig.Clique == nil {
    			logger = log.Warn
    		}
    		logger("已插入已知区块", "number", block.Number(), "hash", block.Hash(),
    			"uncles", len(block.Uncles()), "txs", len(block.Transactions()), "gas", block.GasUsed(),
    			"root", block.Root())
    
    		// 特殊情况。如果我们在中间遇到已知区块，则提交空的收据切片。这只能在 Clique 链中发生。
    		// 每当我们通过 `insertSideChain` 插入区块时，只有在不存在时才提交 `td`、`header` 和 `body`。
    		// 由于没有重新执行，所以没有收据可提交。但是，如果侧链最终将被采纳为规范链，那么它需要重新执行
    		// 以获取丢失的状态，但如果是这种特殊情况（跳过重新执行），我们将丢失空的收据条目。
    		if len(block.Transactions()) == 0 {
    			rawdb.WriteReceipts(bc.db, block.Hash(), block.NumberU64(), nil)
    		} else {
    			log.Error("请提交问题，跳过已知区块的执行而没有收据",
    				"hash", block.Hash(), "number", block.NumberU64())
    		}
    		if err := bc.writeKnownBlock(block); err != nil {
    			return it.index, err
    		}
    		stats.processed++
    
    		// 我们可以假设这里的日志为空，因为连续的 Clique 区块具有相同的状态的唯一方法是如果没有交易。
    		lastCanon = block
    		continue
    	}
    
    	// 获取父区块及其状态以在其之上执行
    	start := time.Now()
    	parent := it.previous()
    	if parent == nil {
    		parent = bc.GetHeader(block.ParentHash(), block.NumberU64()-1)
    	}
    	statedb, err := state.New(parent.Root, bc.stateCache, bc.snaps)
    	if err != nil {
    		return it.index, err
    	}
    
    	// 启用预取以在处理事务时获取 Trie 节点路径
    	statedb.StartPrefetcher("chain")
    	activeState = statedb
    
    	// 如果有后续区块，则针对当前状态运行它以预缓存事务和可能的一些账户/存储 Trie 节点。
    	var followupInterrupt atomic.Bool
    	if !bc.cacheConfig.TrieCleanNoPrefetch {
    		if followup, err := it.peek(); followup != nil && err == nil {
    			throwaway, _ := state.New(parent.Root, bc.stateCache, bc.snaps)
    
    			go func(start time.Time, followup *types.Block, throwaway *state.StateDB) {
    				bc.prefetcher.Prefetch(followup, throwaway, bc.vmConfig, &followupInterrupt)
    
    				blockPrefetchExecuteTimer.Update(time.Since(start))
    				if followupInterrupt.Load() {
    					blockPrefetchInterruptMeter.Mark(1)
    				}
    			}(time.Now(), followup, throwaway)
    		}
    	}
    
    	// 使用父状态作为参考点处理区块
    	pstart := time.Now()
    	receipts, logs, usedGas, err := bc.processor.Process(block, statedb, bc.vmConfig)
    	if err != nil {
    		bc.reportBlock(block, receipts, err)
    		followupInterrupt.Store(true)
    		return it.index, err
    	}
    	ptime := time.Since(pstart)
    
    	vstart := time.Now()
    	if err := bc.validator.ValidateState(block, statedb, receipts, usedGas); err != nil {
    		bc.reportBlock(block, receipts, err)
    		followupInterrupt.Store(true)
    		return it.index, err
    	}
    	vtime := time.Since(vstart)
    	proctime := time.Since(start) // 处理 + 验证
    
    	// 更新在区块处理和验证过程中涉及的指标
    	accountReadTimer.Update(statedb.AccountReads)                   // 账户读取完成（在处理中）
    	storageReadTimer.Update(statedb.StorageReads)                   // 存储读取完成（在处理中）
    	snapshotAccountReadTimer.Update(statedb.SnapshotAccountReads)   // 账户读取完成（在处理中）
    	snapshotStorageReadTimer.Update(statedb.SnapshotStorageReads)   // 存储读取完成（在处理中）
    	accountUpdateTimer.Update(statedb.AccountUpdates)               // 账户更新完成（在验证中）
    	storageUpdateTimer.Update(statedb.StorageUpdates)               // 存储更新完成（在验证中）
    	accountHashTimer.Update(statedb.AccountHashes)                  // 账户哈希完成（在验证中）
    	storageHashTimer.Update(statedb.StorageHashes)                  // 存储哈希完成（在验证中）
    	triehash := statedb.AccountHashes + statedb.StorageHashes       // 用于哈希的时间
    	trieUpdate := statedb.AccountUpdates + statedb.StorageUpdates   // 用于更新的时间
    	trieRead := statedb.SnapshotAccountReads + statedb.AccountReads // 用于账户读取的时间
    	trieRead += statedb.SnapshotStorageReads + statedb.StorageReads // 用于存储读取的时间
    	blockExecutionTimer.Update(ptime - trieRead)                    // EVM 处理的时间
    	blockValidationTimer.Update(vtime - (triehash + trieUpdate))    // 区块验证的时间
    
    	// 将区块写入链并获取状态。
    	var (
    		wstart = time.Now()
    		status WriteStatus
    	)
    	if !setHead {
    		// 不设置头部，只插入区块
    		err = bc.writeBlockWithState(block, receipts, statedb)
    	} else {
    		status, err = bc.writeBlockAndSetHead(block, receipts, logs, statedb, false)
    	}
    	followupInterrupt.Store(true)
    	if err != nil {
    		return it.index, err
    	}
    	// 更新在区块提交过程中涉及的指标
    	accountCommitTimer.Update(statedb.AccountCommits)   // 账户提交完成，我们可以标记它们
    	storageCommitTimer.Update(statedb.StorageCommits)   // 存储提交完成，我们可以标记它们
    	snapshotCommitTimer.Update(statedb.SnapshotCommits) // 快照提交完成，我们可以标记它们
    	triedbCommitTimer.Update(statedb.TrieDBCommits)     // Trie 数据库提交完成，我们可以标记它们
    
    	blockWriteTimer.Update(time.Since(wstart) - statedb.AccountCommits - statedb.StorageCommits - statedb.SnapshotCommits - statedb.TrieDBCommits)
    	blockInsertTimer.UpdateSince(start)
    
    	// 在返回各种结果之前报告导入统计信息
    	stats.processed++
        stats.usedGas += usedGas
        
        dirty, _ := bc.triedb.Size()
        stats.report(chain, it.index, dirty, setHead)
        
        if !setHead {
            // 合并后我们预计会有几个分支链。简单地计算CL给我们的所有块的GC处理时间
            bc.gcproc += proctime
            
            return it.index, nil // 直接插入一个单独的块
        }
        switch status {
        case CanonStatTy:
            log.Debug("插入新块", "编号", block.Number(), "哈希", block.Hash(),
                "叔块数量", len(block.Uncles()), "交易数量", len(block.Transactions()), "消耗的Gas", block.GasUsed(),
                "经过时间", common.PrettyDuration(time.Since(start)),
                "根哈希", block.Root())
        
        lastCanon = block
        
        // 只计算规范块的GC处理时间
        bc.gcproc += proctime
        
        case SideStatTy:
            log.Debug("插入分叉块", "编号", block.Number(), "哈希", block.Hash(),
                "难度", block.Difficulty(), "经过时间", common.PrettyDuration(time.Since(start)),
                "交易数量", len(block.Transactions()), "消耗的Gas", block.GasUsed(), "叔块数量", len(block.Uncles()),
                "根哈希", block.Root())
        
        default:
            // 理论上不可能发生，但为了对我们未来友好，我们留下一条日志，而不是试图追踪不发出日志的块导入。
            log.Warn("插入具有未知状态的块", "编号", block.Number(), "哈希", block.Hash(),
                "难度", block.Difficulty(), "经过时间", common.PrettyDuration(time.Since(start)),
                "交易数量", len(block.Transactions()), "消耗的Gas", block.GasUsed(), "叔块数量", len(block.Uncles()),
                "根哈希", block.Root())
        }
    }
	
    // 这里还有任何剩余的区块吗？我们只关心未来的区块
    if block != nil && errors.Is(err, consensus.ErrFutureBlock) {
        // 如果将来的区块存在且错误为未来区块错误
        if err := bc.addFutureBlock(block); err != nil {
            return it.index, err
        }
        block, err = it.next()
        
        // 循环直到没有未知祖先的区块为止
        for ; block != nil && errors.Is(err, consensus.ErrUnknownAncestor); block, err = it.next() {
            // 如果将来的区块添加失败
            if err := bc.addFutureBlock(block); err != nil {
                return it.index, err
            }
            stats.queued++
        }
    }
    stats.ignored += it.remaining()
    
    return it.index, err
}
```

### ~~WriteBlockAndState~~
### WriteBlockAndState
把区块写入区块链.
```go
// writeBlockWithState函数将区块、元数据和相应的状态数据写入数据库。
func (bc *BlockChain) writeBlockWithState(block *types.Block, receipts []*types.Receipt, state *state.StateDB) error {
	// 计算区块的总难度
	ptd := bc.GetTd(block.ParentHash(), block.NumberU64()-1)
	if ptd == nil {
		return consensus.ErrUnknownAncestor
	}
	// 确保在插入过程中没有泄露不一致的状态
	externTd := new(big.Int).Add(block.Difficulty(), ptd)

	// 不考虑规范状态，将区块本身写入数据库。
	//
	// 注意，所有区块的组成部分（td、hash->number映射、头部、主体、收据）都应该原子地写入。
	// BlockBatch用于包含所有组件。
	blockBatch := bc.db.NewBatch()
	rawdb.WriteTd(blockBatch, block.Hash(), block.NumberU64(), externTd)
	rawdb.WriteBlock(blockBatch, block)
	rawdb.WriteReceipts(blockBatch, block.Hash(), block.NumberU64(), receipts)
	rawdb.WritePreimages(blockBatch, state.Preimages())
	if err := blockBatch.Write(); err != nil {
		log.Crit("Failed to write block into disk", "err", err)
	}
	// 将所有缓存的状态更改提交到底层内存数据库。
	root, err := state.Commit(bc.chainConfig.IsEIP158(block.Number()))
	if err != nil {
		return err
	}
	// 如果我们正在运行存档节点，则始终刷新
	if bc.cacheConfig.TrieDirtyDisabled {
		return bc.triedb.Commit(root, false)
	}
	// 完整但不是存档节点，进行适当的垃圾回收
	bc.triedb.Reference(root, common.Hash{}) // 元数据引用以保持trie的活性
	bc.triegc.Push(root, -int64(block.NumberU64()))

	current := block.NumberU64()
	// 对于前TriesInMemory个区块，不考虑刷新限制。
	if current <= TriesInMemory {
		return nil
	}
	// 如果超过内存限制，则将成熟的单例节点刷新到磁盘
	var (
		nodes, imgs = bc.triedb.Size()
		limit       = common.StorageSize(bc.cacheConfig.TrieDirtyLimit) * 1024 * 1024
	)
	if nodes > limit || imgs > 4*1024*1024 {
		bc.triedb.Cap(limit - ethdb.IdealBatchSize)
	}
	// 找到下一个需要提交的状态trie
	chosen := current - TriesInMemory
	flushInterval := time.Duration(bc.flushInterval.Load())
	// 如果超过时间限制，则将整个trie刷新到磁盘
	if bc.gcproc > flushInterval {
		// 如果缺少头部（规范链落后），则正在重组一个低难度的侧链。暂停提交直到此操作完成。
		header := bc.GetHeaderByNumber(chosen)
		if header == nil {
			log.Warn("Reorg in progress, trie commit postponed", "number", chosen)
		} else {
			// 如果超过限制但尚未达到足够大的内存间隙，警告用户系统正在变得不稳定。
			if chosen < bc.lastWrite+TriesInMemory && bc.gcproc >= 2*flushInterval {
				log.Info("State in memory for too long, committing", "time", bc.gcproc, "allowance", flushInterval, "optimum", float64(chosen-bc.lastWrite)/TriesInMemory)
			}
			// 刷新整个trie并重新开始计数器
			bc.triedb.Commit(header.Root, true)
			bc.lastWrite = chosen
			bc.gcproc = 0
		}
	}
	// 垃圾回收低于所需的写入保留
	for !bc.triegc.Empty() {
		root, number := bc.triegc.Pop()
		if uint64(-number) > chosen {
			bc.triegc.Push(root, number)
			break
		}
		bc.triedb.Dereference(root)
	}
	return nil
}
```




















