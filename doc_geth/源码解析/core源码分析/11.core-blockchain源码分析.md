从测试案例来看,blockchain的主要功能点有下面几点.
1. import.
2. GetLastBlock的功能.
3. 如果有多条区块链,可以选取其中难度最大的一条作为规范的区块链.
4. BadHashes 可以手工禁止接受一些区块的hash值.在blocks.go里面.
5. 如果新配置了BadHashes. 那么区块启动的时候会自动禁止并进入有效状态.
6. 错误的nonce会被拒绝.
7. 支持Fast importing.
8. Light vs Fast vs Full processing 在处理区块头上面的效果相等.

可以看到blockchain的主要功能是维护区块链的状态, 包括区块的验证,插入和状态查询.

### 名词解释:
什么是规范的区块链？

因为在区块的创建过程中,可能在短时间内产生一些分叉, 在我们的数据库里面记录的其实是一颗区块树.我们会认为其中总难度最高的一条路径认为是我们的规范的区块链. 这样有很多区块虽然也能形成区块链,但是不是规范的区块链.

### 数据库结构(暂时没看懂)
```go
区块的hash值和区块头的hash值是同样的么。所谓的区块的Hash值其实就是Header的区块值。
// key -> value
// + 代表连接

"LastHeader"  最新的区块头 HeaderChain中使用
"LastBlock"   最新的区块头 BlockChain 中使用
"LastFast"    最新的快速同步的区块头

"h"+num+"n" -> hash  用来存储规范的区块链的高度和区块头的hash值

"h" + num + hash -> header 高度+hash值 -> 区块头

"h" + num + hash + "t" -> td  高度+hash值 -> 总难度

"H" + hash -> num  区块体hash -> 高度

"b" + num + hash -> block body   高度+hash值 -> 区块体

"r" + num + hash -> block receipts  高度 + hash值 -> 区块收据

"l" + hash -> transaction/receipt lookup metadata
```

|key | value|说明|插入|删除|
|---- | --- |---------------|-----------|-----------|
|"LastHeader" | hash | 最新的区块头 HeaderChain中使用|当区块被认为是当前最新的一个规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"LastBlock" |  hash | 最新的区块头 BlockChain中使用|当区块被认为是当前最新的一个规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"LastFast" | hash |  最新的区块头 BlockChain中使用|当区块被认为是当前最新的规范的区块链头|当有了更新的区块链头或者是分叉的兄弟区块链替代了它|
|"h"+num+"n"|hash|用来存储规范的区块链的高度和区块头的hash值 在HeaderChain中使用|当区块在规范的区块链中|当区块不在规范的区块链中|
|"h" + num + hash + "t"|td|总难度|WriteBlockAndState当验证并执行完一个区块之后(不管是不是规范的)|SetHead方法会调用。这种方法只会在两种情况下被调用，1是当前区块链包含了badhashs，需要删除所有从badhashs开始的区块， 2.是当前区块的状态错误，需要Reset到genesis。|
|"H" + hash | num| 区块的高度 在HeaderChain中使用|WriteBlockAndState当验证并执行完一个区块之后|SetHead中被调用，同上|
|"b" + num + hash|block body| 区块数据| WriteBlockAndState or InsertReceiptChain|SetHead中被删除，同上|
|"r" + num + hash|block receipts|区块收据|WriteBlockAndState or InsertReceiptChain|同上|
|"l" + txHash | {hash,num,TxIndex|交易hash可以找到区块和交易|当区块加入规范的区块链|当区块从规范的区块链移除|

### 数据结构
```go
// BlockChain表示具有创世块的数据库中的规范链。Blockchain管理链的导入、回滚和链重组。
//
// 将块导入到区块链中是根据两阶段验证器定义的一组规则进行的。
// 块的处理是使用处理器进行的，处理其中包含的交易。
// 状态的验证是在验证器的第二部分中完成的。如果验证失败，则导入中止。
//
// BlockChain还有助于从数据库中包含的**任何**链返回块，以及代表规范链的块。
// 需要注意的是，GetBlock可以返回任何块，并不一定需要包含在规范链中，而GetBlockByNumber始终表示规范链。
type BlockChain struct {
	chainConfig *params.ChainConfig // 链和网络配置
	cacheConfig *CacheConfig        // 剪枝的缓存配置

	db            ethdb.Database                   // 用于存储最终内容的底层持久性数据库
	snaps         *snapshot.Tree                   // 用于快速trie叶子访问的快照树
	triegc        *prque.Prque[int64, common.Hash] // 将块号映射到要进行垃圾回收的tries的优先级队列
	gcproc        time.Duration                    // 积累规范块处理以进行trie转储
	lastWrite     uint64                           // 状态刷新时的最后一个块
	flushInterval atomic.Int64                     // 在此之后刷新状态的时间间隔（处理时间）
	triedb        *trie.Database                   // 用于维护trie节点的数据库处理程序。
	stateCache    state.Database                   // 在导入之间重用的状态数据库（包含状态缓存）

	// txLookupLimit是保留事务索引的从头部开始的最大块数：
	//  * 0:   表示没有限制，并重新生成任何丢失的索引
	//  * N:   表示N个块的限制[HEAD-N+1, HEAD]并删除额外的索引
	//  * nil: 禁用tx重新索引器/删除器，但仍然索引新的块
	txLookupLimit uint64

	hc            *HeaderChain
	rmLogsFeed    event.Feed
	chainFeed     event.Feed
	chainSideFeed event.Feed
	chainHeadFeed event.Feed
	logsFeed      event.Feed
	blockProcFeed event.Feed
	scope         event.SubscriptionScope
	genesisBlock  *types.Block

	// 此互斥锁同步链写操作。
	// 读者不需要获取它，只需读取数据库即可。
	chainmu *syncx.ClosableMutex

	currentBlock      atomic.Pointer[types.Header] // 链的当前头
	currentSnapBlock  atomic.Pointer[types.Header] // 当前快照同步的头
	currentFinalBlock atomic.Pointer[types.Header] // 最新（共识）的已最终化块
	currentSafeBlock  atomic.Pointer[types.Header] // 最新（共识）的安全块

	bodyCache     *lru.Cache[common.Hash, *types.Body]
	bodyRLPCache  *lru.Cache[common.Hash, rlp.RawValue]
	receiptsCache *lru.Cache[common.Hash, []*types.Receipt]
	blockCache    *lru.Cache[common.Hash, *types.Block]
	txLookupCache *lru.Cache[common.Hash, *rawdb.LegacyTxLookupEntry]

	// 未来块是添加以供稍后处理的块
	futureBlocks *lru.Cache[common.Hash, *types.Block]

	wg            sync.WaitGroup //
	quit          chan struct{}  // 关闭信号，在Stop中关闭。
	stopping      atomic.Bool    // 如果链正在运行，则为false，如果停止，则为true
	procInterrupt atomic.Bool    // 用于块处理的中断信号

	engine     consensus.Engine
	validator  Validator // 块和状态验证器接口
	prefetcher Prefetcher
	processor  Processor // 块事务处理器接口
	forker     *ForkChoice
	vmConfig   vm.Config
}
```

### 构造方法NewBlockChain
使用数据库里面的可用信息构造了一个初始化好的区块链. 同时初始化了以太坊默认的 验证器和处理器 (Validator and Processor)
```go
// NewBlockChain 返回一个完全初始化的区块链，使用数据库中可用的信息。
// 它初始化了默认的以太坊验证器和处理器。
func NewBlockChain(db ethdb.Database, cacheConfig *CacheConfig, genesis *Genesis, overrides *ChainOverrides, engine consensus.Engine, vmConfig vm.Config, shouldPreserve func(header *types.Header) bool, txLookupLimit *uint64) (*BlockChain, error) {
	if cacheConfig == nil {
		cacheConfig = defaultCacheConfig
	}
	// 使用提供的配置打开 trie 数据库
	triedb := trie.NewDatabaseWithConfig(db, &trie.Config{
		Cache:     cacheConfig.TrieCleanLimit,
		Journal:   cacheConfig.TrieCleanJournal,
		Preimages: cacheConfig.Preimages,
	})
	// 设置创世块，如果创世块尚不存在，则将提供的创世规范提交到数据库中，否则从数据库中加载已存储的创世块。
	chainConfig, genesisHash, genesisErr := SetupGenesisBlockWithOverride(db, triedb, genesis, overrides)
	if _, ok := genesisErr.(*params.ConfigCompatError); genesisErr != nil && !ok {
		return nil, genesisErr
	}
	log.Info("")
	log.Info(strings.Repeat("-", 153))
	for _, line := range strings.Split(chainConfig.Description(), "\n") {
		log.Info(line)
	}
	log.Info(strings.Repeat("-", 153))
	log.Info("")

	bc := &BlockChain{
		chainConfig:   chainConfig,
		cacheConfig:   cacheConfig,
		db:            db,
		triedb:        triedb,
		triegc:        prque.New[int64, common.Hash](nil),
		quit:          make(chan struct{}),
		chainmu:       syncx.NewClosableMutex(),
		bodyCache:     lru.NewCache[common.Hash, *types.Body](bodyCacheLimit),
		bodyRLPCache:  lru.NewCache[common.Hash, rlp.RawValue](bodyCacheLimit),
		receiptsCache: lru.NewCache[common.Hash, []*types.Receipt](receiptsCacheLimit),
		blockCache:    lru.NewCache[common.Hash, *types.Block](blockCacheLimit),
		txLookupCache: lru.NewCache[common.Hash, *rawdb.LegacyTxLookupEntry](txLookupCacheLimit),
		futureBlocks:  lru.NewCache[common.Hash, *types.Block](maxFutureBlocks),
		engine:        engine,
		vmConfig:      vmConfig,
	}
	bc.flushInterval.Store(int64(cacheConfig.TrieTimeLimit))
	bc.forker = NewForkChoice(bc, shouldPreserve)
	bc.stateCache = state.NewDatabaseWithNodeDB(bc.db, bc.triedb)
	bc.validator = NewBlockValidator(chainConfig, bc, engine)
	bc.prefetcher = newStatePrefetcher(chainConfig, bc, engine)
	bc.processor = NewStateProcessor(chainConfig, bc, engine)

	var err error
	bc.hc, err = NewHeaderChain(db, chainConfig, engine, bc.insertStopped)
	if err != nil {
		return nil, err
	}
	bc.genesisBlock = bc.GetBlockByNumber(0)
	if bc.genesisBlock == nil {
		return nil, ErrNoGenesis
	}

	bc.currentBlock.Store(nil)
	bc.currentSnapBlock.Store(nil)
	bc.currentFinalBlock.Store(nil)
	bc.currentSafeBlock.Store(nil)

	// 如果 Geth 初始化时使用外部古代存储，则重新初始化丢失的链索引和链标志。
	// 这个过程可以在崩溃后继续进行，并且可以在下一次重启中恢复，因为链标志在最后一步中更新。
	if bc.empty() {
		rawdb.InitDatabaseFromFreezer(bc.db)
	}
	// 从磁盘加载区块链状态
	if err := bc.loadLastState(); err != nil {
		return nil, err
	}
	// 确保与块关联的状态可用
	head := bc.CurrentBlock()
	if !bc.HasState(head.Root) {
		// 头状态丢失，在进行状态恢复之前，找出快照的磁盘层点（如果启用了快照）。
		// 确保回绕点低于磁盘层。
		var diskRoot common.Hash
		if bc.cacheConfig.SnapshotLimit > 0 {
			diskRoot = rawdb.ReadSnapshotRoot(bc.db)
		}
		if diskRoot != (common.Hash{}) {
			log.Warn("头状态丢失，修复中", "number", head.Number, "hash", head.Hash(), "snaproot", diskRoot)

			snapDisk, err := bc.setHeadBeyondRoot(head.Number.Uint64(), 0, diskRoot, true)
			if err != nil {
				return nil, err
			}
			// 链回绕，将旧快照号持久化以指示恢复过程
			if snapDisk != 0 {
				rawdb.WriteSnapshotRecoveryNumber(bc.db, snapDisk)
			}
		} else {
			log.Warn("头状态丢失，修复中", "number", head.Number, "hash", head.Hash())
			if _, err := bc.setHeadBeyondRoot(head.Number.Uint64(), 0, common.Hash{}, true); err != nil {
				return nil, err
			}
		}
	}
	// 确保 SetHead 中的上一次崩溃不会留下额外的古代块
	if frozen, err := bc.db.Ancients(); err == nil && frozen > 0 {
		var (
			needRewind bool
			low        uint64
		)
		// 由于区块链修复，完整块可能会回滚到非常低的高度。
		// 如果完整块甚至低于古代链，截断古代存储。
		fullBlock := bc.CurrentBlock()
		if fullBlock != nil && fullBlock.Hash() != bc.genesisBlock.Hash() && fullBlock.Number.Uint64() < frozen-1 {
			needRewind = true
			low = fullBlock.Number.Uint64()
		}
		// 在快速同步中，可能已将古代数据写入古代存储，但 LastFastBlock 尚未更新，此处截断额外数据。
		snapBlock := bc.CurrentSnapBlock()
		if snapBlock != nil && snapBlock.Number.Uint64() < frozen-1 {
			needRewind = true
			if snapBlock.Number.Uint64() < low || low == 0 {
				low = snapBlock.Number.Uint64()
			}
		}
		if needRewind {
			log.Error("截断古代链", "from", bc.CurrentHeader().Number.Uint64(), "to", low)
			if err := bc.SetHead(low); err != nil {
				return nil, err
			}
		}
	}
	// 节点的第一件事是重建头块的验证数据（ethash 缓存或 clique 投票快照），最好提前做。
	bc.engine.VerifyHeader(bc, bc.CurrentHeader())

	// 检查块哈希的当前状态，并确保我们的链中没有任何坏块
	for hash := range BadHashes {
		if header := bc.GetHeaderByHash(hash); header != nil {
			// 获取与有问题的头部的数字对应的规范块
			headerByNumber := bc.GetHeaderByNumber(header.Number.Uint64())
			// 确保 headerByNumber（如果存在）在当前的规
            if headerByNumber != nil && headerByNumber.Hash() == header.Hash() {
                log.Error("Found bad hash, rewinding chain", "number", header.Number, "hash", header.ParentHash)
                if err := bc.SetHead(header.Number.Uint64() - 1); err != nil {
                    return nil, err
                }
                log.Error("Chain rewind was successful, resuming normal operation")
			}
		}
    }
    // 加载任何现有的快照，如果加载失败则重新生成
    if bc.cacheConfig.SnapshotLimit > 0 {
        // 如果链被回滚到快照持久层（导致恢复块号被持久化到磁盘），检查是否仍处于恢复模式，
		// 如果是，则在头不匹配的情况下不使快照失效。
        var recover bool
        
        head := bc.CurrentBlock()
        if layer := rawdb.ReadSnapshotRecoveryNumber(bc.db); layer != nil && *layer >= head.Number.Uint64() {
            log.Warn("启用快照恢复", "链头", head.Number, "磁盘基础", *layer)
            recover = true
        }
        snapconfig := snapshot.Config{
            CacheSize:  bc.cacheConfig.SnapshotLimit,
            Recovery:   recover,
            NoBuild:    bc.cacheConfig.SnapshotNoBuild,
            AsyncBuild: !bc.cacheConfig.SnapshotWait,
        }
        bc.snaps, _ = snapshot.New(snapconfig, bc.db, bc.triedb, head.Root)
    }
    
    // 启动未来区块处理器。
    bc.wg.Add(1)
    go bc.updateFutureBlocks()
    
    // 如果需要定期清理缓存日志，启动它。
    if bc.cacheConfig.TrieCleanRejournal > 0 {
        if bc.cacheConfig.TrieCleanRejournal < time.Minute {
            log.Warn("清理无效的Trie缓存日志时间", "提供的", bc.cacheConfig.TrieCleanRejournal, "更新为", time.Minute)
            bc.cacheConfig.TrieCleanRejournal = time.Minute
        }
        bc.wg.Add(1)
        go func() {
            defer bc.wg.Done()
            bc.triedb.SaveCachePeriodically(bc.cacheConfig.TrieCleanJournal, bc.cacheConfig.TrieCleanRejournal, bc.quit)
        }()
    }
    // 在不兼容的配置升级的情况下回滚链。
    if compat, ok := genesisErr.(*params.ConfigCompatError); ok {
        log.Warn("回滚链以升级配置", "错误", compat)
        if compat.RewindToTime > 0 {
            bc.SetHeadWithTimestamp(compat.RewindToTime)
        } else {
            bc.SetHead(compat.RewindToBlock)
        }
        rawdb.WriteChainConfig(db, genesisHash, chainConfig)
    }
    // 如果需要，启动交易索引器/反索引器。
    if txLookupLimit != nil {
        bc.txLookupLimit = *txLookupLimit
        
        bc.wg.Add(1)
        go bc.maintainTxIndex()
    }
    return bc, nil
}
```















































