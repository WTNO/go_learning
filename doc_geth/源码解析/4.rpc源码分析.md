## RPC包的打大致结构
网络协议 channels和Json格式的 请求和回应的 编码和解码 都是同时与 服务端和客户端 打交道的类。

网络协议channels主要提供连接和数据传输的功能。 json格式的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -> Go的对象)。

<img src="../img/rpc_1.png">

## 源码解析
### server.go
`server.go`主要实现了RPC服务端的核心逻辑。 包括RPC方法的注册， 读取请求，处理请求，发送回应等逻辑。 

server的核心数据结构是Server结构体。其中，
- `services`字段是一个结构体，包含了一个map和一个锁，记录了所有注册的方法和类。 
- `run`参数是用来控制Server的运行和停止的。 
- `codecs`是一个set， 用来存储所有的编码解码器，其实就是所有的连接。
- `mutex`是用来保护多线程访问codecs的锁。

`services`字段的value类型是service类型。 service代表了一个注册到Server的实例， 是一个对象和方法的组合。 service字段的name代表了service的namespace， callbacks是实例的回调方法， subscriptions是实例的订阅方法。
```go
// Server is an RPC server.
type Server struct {
	services serviceRegistry
	idgen    func() ID

	mutex              sync.Mutex
	codecs             map[ServerCodec]struct{}
	run                atomic.Bool
	batchItemLimit     int
	batchResponseLimit int
}

type serviceRegistry struct {
    mu       sync.Mutex
    services map[string]service
}

// service represents a registered object.
type service struct {
    name          string               // 服务的名称
    callbacks     map[string]*callback // 已注册的处理程序
    subscriptions map[string]*callback // 可用的订阅/通知
}
```

#### Server的创建
Server创建的时候通过调用server.RegisterName把自己的实例注册上来，提供一些RPC服务的元信息。
```go
// NewServer creates a new server instance with no registered handlers.
func NewServer() *Server {
	server := &Server{
		idgen:  randomIDGenerator(),
		codecs: make(map[ServerCodec]struct{}),
	}
	server.run.Store(true)
	// Register the default service providing meta information about the RPC service such
	// as the services and methods it offers.
	rpcService := &RPCService{server}
	server.RegisterName(MetadataApi, rpcService)
	return server
}
```

服务注册`server.RegisterName`，`RegisterName`方法会通过传入的参数来创建一个service对象，如果传入的receiver实例没有找到任何合适的方法，那么会返回错误。 如果没有错误，就把创建的service实例加入serviceRegistry。
```go
// RegisterName函数会根据给定的名称和接收器类型创建一个服务。
// 当给定接收器没有匹配到符合RPC方法或订阅的条件时，函数会返回一个错误。
// 否则，函数会创建一个新的服务并将其添加到该服务器提供给客户端的服务集合中。
func (s *Server) RegisterName(name string, receiver interface{}) error {
	return s.services.registerName(name, receiver)
}

func (r *serviceRegistry) registerName(name string, rcvr interface{}) error {
    rcvrVal := reflect.ValueOf(rcvr)
    if name == "" {
        return fmt.Errorf("no service name for type %s", rcvrVal.Type().String())
    }
    callbacks := suitableCallbacks(rcvrVal)
    if len(callbacks) == 0 {
        return fmt.Errorf("service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
    }
    
    r.mu.Lock()
    defer r.mu.Unlock()
    if r.services == nil {
        r.services = make(map[string]service)
    }
    // 如果这个名字当前没有被注册过，那么直接初始化并插入。
    svc, ok := r.services[name]
    if !ok {
        svc = service{
            name:          name,
            callbacks:     make(map[string]*callback),
            subscriptions: make(map[string]*callback),
        }
        r.services[name] = svc
    }
    for name, cb := range callbacks {
        if cb.isSubscribe {
            svc.subscriptions[name] = cb
        } else {
            svc.callbacks[name] = cb
        }
    }
    return nil
}
```

`suitableCallbacks` 通过反射信息找出合适的方法。 这个方法会遍历这个类型的所有方法，找到适配RPC callback或者subscription callback类型标准的方法并返回。关于RPC的标准，请参考文档开头的RPC标准。
```go
// suitableCallbacks函数会遍历给定类型的方法。
// 它会确定一个方法是否满足RPC回调或订阅回调的条件，并将其添加到回调集合中。
func suitableCallbacks(receiver reflect.Value) map[string]*callback {
    typ := receiver.Type()
    callbacks := make(map[string]*callback)
    for m := 0; m < typ.NumMethod(); m++ {
        method := typ.Method(m)
        if method.PkgPath != "" {
            continue // method not exported
        }
		// 将fn（一个函数）转换为一个回调对象。如果该函数不适合作为RPC回调，则返回nil。
        cb := newCallback(receiver, method.Func)
        if cb == nil {
            continue // function invalid
        }
        name := formatName(method.Name)
        callbacks[name] = cb
    }
    return callbacks
}
```

#### server启动和服务
server的启动和服务这里参考ipc.go中的一部分代码。可以看到每`Accept()`一个链接，就启动一个goroutine调用`srv.ServeCodec`来进行服务，这里也可以看出JsonCodec的功能，Codec类似于装饰器模式，在连接外面包了一层。
```go
// ServeListener函数在l上接受连接，为它们提供JSON-RPC服务。
func (s *Server) ServeListener(l net.Listener) error {
	for {
		conn, err := l.Accept()
		if netutil.IsTemporaryError(err) {
			log.Warn("RPC accept error", "err", err)
			continue
		} else if err != nil {
			return err
		}
		log.Trace("Accepted RPC connection", "conn", conn.RemoteAddr())
		go s.ServeCodec(NewCodec(conn), 0)
	}
}
```

`ServeCodec` 这个方法很简单，提供了codec.Close的关闭功能。 ~~serveRequest的第二个参数singleShot是控制长连接还是短连接的参数，如果singleShot为真，那么处理完一个请求之后会退出。 不过咱们的serveRequest方法是一个死循环，不遇到异常，或者客户端主动关闭，服务端是不会关闭的。 所以rpc提供的是长连接的功能。~~
```go
// ServeCodec函数从codec读取传入的请求，调用适当的回调函数，并使用给定的codec将响应写回。
// 它会阻塞，直到codec关闭或服务器停止。
// 在任一情况下，codec都会被关闭。
// 请注意，不再支持codec选项。
func (s *Server) ServeCodec(codec ServerCodec, options CodecOption) {
	defer codec.close()

	if !s.trackCodec(codec) {
		return
	}
	defer s.untrackCodec(codec)

	cfg := &clientConfig{
		idgen:              s.idgen,
		batchItemLimit:     s.batchItemLimit,
		batchResponseLimit: s.batchResponseLimit,
	}
	c := initClient(codec, &s.services, cfg)
	<-codec.closed()
	c.Close()
}
```

~~我们的重磅方法终于出场，serveRequest 这个方法就是Server的主要处理流程。从codec读取请求，找到对应的方法并调用，然后把回应写入codec。~~
这部分没看懂，待研究

#### subscription.go 发布订阅模式
















