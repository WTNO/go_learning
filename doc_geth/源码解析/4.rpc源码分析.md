## RPC包的打大致结构
网络协议 channels和Json格式的 请求和回应的 编码和解码 都是同时与 服务端和客户端 打交道的类。

网络协议channels主要提供连接和数据传输的功能。 json格式的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -> Go的对象)。

<img src="../img/rpc_1.png">

## 源码解析
### 启动流程
以太坊节点是如何实现RPC服务的呢，我们先从节点启动流程分析一下。如下图所示：

<img src="../img/rpc启动流程.jpg">

上图所示流程是以太坊节点从命令行执行启动后，一路初始化过程，先启动Node，在Node下面有一系列服务，RPC是其中之一，http协议的RPC又是几种RPC服务之一。

geth的startNode方法中，通过层层跟踪可以进入到了Node.Start()方法，在start方法中，有一个startRPC方法，启动节点的RPC。
```go
// startRPC is a helper method to configure all the various RPC endpoints during node
// startup. It's not meant to be called at any time afterwards as it makes certain
// assumptions about the state of the node.
func (n *Node) startRPC() error {
    ...
	
    initHttp := func(server *httpServer, port int) error {
    if err := server.setListenAddr(n.config.HTTPHost, port); err != nil {
        return err
    }
    if err := server.enableRPC(openAPIs, httpConfig{
        CorsAllowedOrigins: n.config.HTTPCors,
        Vhosts:             n.config.HTTPVirtualHosts,
        Modules:            n.config.HTTPModules,
        prefix:             n.config.HTTPPathPrefix,
        rpcEndpointConfig:  rpcConfig,
    }); err != nil {
        return err
    }
    servers = append(servers, server)
    return nil
    }
	
	...
}
```

`initHttp`完成了Http RPC服务器的初始化工作。首先设置侦听地址和端口，默认端口8545。然后设置服务器配置信息，包括对外开放的api，http跨域访问，虚拟主机等。设置完成后，将server结构放入到server列表，后续会一一调用start()启动服务。

其中`server.enableRPC()`传入的第一个参数openAPIs就是对外开放服务的api。通过node.apis()方法获得。来看一下apis()的定义。
```go
// apis返回内置的RPC API集合。
func (n *Node) apis() []rpc.API {
	return []rpc.API{
		{
			Namespace: "admin",
			Service:   &adminAPI{n},
		}, {
			Namespace: "debug",
			Service:   debug.Handler,
		}, {
			Namespace: "web3",
			Service:   &web3API{n},
		},
	}
}

// adminAPI is the collection of administrative API methods exposed over
// both secure and unsecure RPC channels.
type adminAPI struct {
    node *Node // Node interfaced by this API
}

// AddPeer requests connecting to a remote node, and also maintaining the new
// connection at all times, even reconnecting if it is lost.
func (api *adminAPI) AddPeer(url string) (bool, error) {
    // Make sure the server is running, fail otherwise
    server := api.node.Server()
    if server == nil {
        return false, ErrNodeStopped
    }
    // Try to add the url as a static peer and return
    node, err := enode.Parse(enode.ValidSchemes, url)
    if err != nil {
        return false, fmt.Errorf("invalid enode: %v", err)
    }
    server.AddPeer(node)
    return true, nil
}

// Peers retrieves all the information we know about each individual peer at the
// protocol granularity.
func (api *adminAPI) Peers() ([]*p2p.PeerInfo, error) {
    server := api.node.Server()
    if server == nil {
        return nil, ErrNodeStopped
    }
    return server.PeersInfo(), nil
}
```
可以看到，定义了3组API，其中Namespace可认为是API的前缀,一般都是通过`Namespace_方法名`的形式访问。实际上RPC服务的解析过程就是拿到`Namespace_方法名`形式的字符串，然后根据"_"分成两部分，然后从函数映射表中找到`Namespace`路径下的对应的方法地址，执行过程调用返回结果。

Service是接口类型，以`admin`为例，凡是adminAPI类型下的方法，都可以通过Service入口调用，即运行时通过Service的入口，可以找到并执行对应的方法。

比如执行Peers()方法，可以执行
```
curl -XPOST http://localhost:8545 -H 'Content-Type: application/json' -d '{"method": "admin_peers", "params": [], "id":1}'
```

接下来的流程如下图所示:

<img src="../img/rpc启动流程2.jpg">

### server.go
`server.go`主要实现了RPC服务端的核心逻辑。 包括RPC方法的注册， 读取请求，处理请求，发送回应等逻辑。 

server的核心数据结构是Server结构体。其中，
- `services`字段是一个结构体，包含了一个map和一个锁，记录了所有注册的方法和类。 
- `run`参数是用来控制Server的运行和停止的。 
- `codecs`是一个set， 用来存储所有的编码解码器，其实就是所有的连接。
- `mutex`是用来保护多线程访问codecs的锁。

`services`字段的value类型是service类型。 service代表了一个注册到Server的实例， 是一个对象和方法的组合。 service字段的name代表了service的namespace， callbacks是实例的回调方法， subscriptions是实例的订阅方法。
```go
// Server is an RPC server.
type Server struct {
	services serviceRegistry
	idgen    func() ID

	mutex              sync.Mutex
	codecs             map[ServerCodec]struct{}
	run                atomic.Bool
	batchItemLimit     int
	batchResponseLimit int
}

type serviceRegistry struct {
    mu       sync.Mutex
    services map[string]service
}

// service represents a registered object.
type service struct {
    name          string               // 服务的名称
    callbacks     map[string]*callback // 已注册的处理程序
    subscriptions map[string]*callback // 可用的订阅/通知
}
```

#### Server的创建
Server创建的时候通过调用server.RegisterName把自己的实例注册上来，提供一些RPC服务的元信息。
```go
// NewServer creates a new server instance with no registered handlers.
func NewServer() *Server {
	server := &Server{
		idgen:  randomIDGenerator(),
		codecs: make(map[ServerCodec]struct{}),
	}
	server.run.Store(true)
	// Register the default service providing meta information about the RPC service such
	// as the services and methods it offers.
	rpcService := &RPCService{server}
	server.RegisterName(MetadataApi, rpcService)
	return server
}
```

服务注册`server.RegisterName`，`RegisterName`方法会通过传入的参数来创建一个service对象，如果传入的receiver实例没有找到任何合适的方法，那么会返回错误。 如果没有错误，就把创建的service实例加入serviceRegistry。
```go
// RegisterName函数会根据给定的名称和接收器类型创建一个服务。
// 当给定接收器没有匹配到符合RPC方法或订阅的条件时，函数会返回一个错误。
// 否则，函数会创建一个新的服务并将其添加到该服务器提供给客户端的服务集合中。
func (s *Server) RegisterName(name string, receiver interface{}) error {
	return s.services.registerName(name, receiver)
}

func (r *serviceRegistry) registerName(name string, rcvr interface{}) error {
    rcvrVal := reflect.ValueOf(rcvr)
    if name == "" {
        return fmt.Errorf("no service name for type %s", rcvrVal.Type().String())
    }
    callbacks := suitableCallbacks(rcvrVal)
    if len(callbacks) == 0 {
        return fmt.Errorf("service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
    }
    
    r.mu.Lock()
    defer r.mu.Unlock()
    if r.services == nil {
        r.services = make(map[string]service)
    }
    // 如果这个名字当前没有被注册过，那么直接初始化并插入。
    svc, ok := r.services[name]
    if !ok {
        svc = service{
            name:          name,
            callbacks:     make(map[string]*callback),
            subscriptions: make(map[string]*callback),
        }
        r.services[name] = svc
    }
    for name, cb := range callbacks {
        if cb.isSubscribe {
            svc.subscriptions[name] = cb
        } else {
            svc.callbacks[name] = cb
        }
    }
    return nil
}
```

`suitableCallbacks` 通过反射信息找出合适的方法。 这个方法会遍历这个类型的所有方法，找到适配RPC callback或者subscription callback类型标准的方法并返回。关于RPC的标准，请参考文档开头的RPC标准。
```go
// suitableCallbacks函数会遍历给定类型的方法。
// 它会确定一个方法是否满足RPC回调或订阅回调的条件，并将其添加到回调集合中。
func suitableCallbacks(receiver reflect.Value) map[string]*callback {
    typ := receiver.Type()
    callbacks := make(map[string]*callback)
    for m := 0; m < typ.NumMethod(); m++ {
        method := typ.Method(m)
        if method.PkgPath != "" {
            continue // method not exported
        }
		// 将fn（一个函数）转换为一个回调对象。如果该函数不适合作为RPC回调，则返回nil。
        cb := newCallback(receiver, method.Func)
        if cb == nil {
            continue // function invalid
        }
        name := formatName(method.Name)
        callbacks[name] = cb
    }
    return callbacks
}
```

#### server启动和服务
server的启动和服务这里参考ipc.go中的一部分代码。可以看到每`Accept()`一个链接，就启动一个goroutine调用`srv.ServeCodec`来进行服务，这里也可以看出JsonCodec的功能，Codec类似于装饰器模式，在连接外面包了一层。
```go
// ServeListener函数在l上接受连接，为它们提供JSON-RPC服务。
func (s *Server) ServeListener(l net.Listener) error {
	for {
		conn, err := l.Accept()
		if netutil.IsTemporaryError(err) {
			log.Warn("RPC accept error", "err", err)
			continue
		} else if err != nil {
			return err
		}
		log.Trace("Accepted RPC connection", "conn", conn.RemoteAddr())
		go s.ServeCodec(NewCodec(conn), 0)
	}
}
```

`ServeCodec` 这个方法很简单，提供了codec.Close的关闭功能。 ~~serveRequest的第二个参数singleShot是控制长连接还是短连接的参数，如果singleShot为真，那么处理完一个请求之后会退出。 不过咱们的serveRequest方法是一个死循环，不遇到异常，或者客户端主动关闭，服务端是不会关闭的。 所以rpc提供的是长连接的功能。~~
```go
// ServeCodec函数从codec读取传入的请求，调用适当的回调函数，并使用给定的codec将响应写回。
// 它会阻塞，直到codec关闭或服务器停止。
// 在任一情况下，codec都会被关闭。
// 请注意，不再支持codec选项。
func (s *Server) ServeCodec(codec ServerCodec, options CodecOption) {
	defer codec.close()

	if !s.trackCodec(codec) {
		return
	}
	defer s.untrackCodec(codec)

	cfg := &clientConfig{
		idgen:              s.idgen,
		batchItemLimit:     s.batchItemLimit,
		batchResponseLimit: s.batchResponseLimit,
	}
	c := initClient(codec, &s.services, cfg)
	<-codec.closed()
	c.Close()
}
```

~~我们的重磅方法终于出场，serveRequest 这个方法就是Server的主要处理流程。从codec读取请求，找到对应的方法并调用，然后把回应写入codec。~~
这部分没看懂，待研究

#### subscription.go 发布订阅模式
















