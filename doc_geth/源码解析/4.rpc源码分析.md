## RPC包的打大致结构
网络协议 channels和Json格式的 请求和回应的 编码和解码 都是同时与 服务端和客户端 打交道的类。

网络协议channels主要提供连接和数据传输的功能。 json格式的编码和解码主要提供请求和回应的序列化和反序列化功能(Json -> Go的对象)。

<img src="../img/rpc_1.png">

## 源码解析
### 启动流程
以太坊节点是如何实现RPC服务的呢，我们先从节点启动流程分析一下。如下图所示：

<img src="../img/rpc启动流程.jpg">

上图所示流程是以太坊节点从命令行执行启动后，一路初始化过程，先启动Node，在Node下面有一系列服务，RPC是其中之一，http协议的RPC又是几种RPC服务之一。

geth的startNode方法中，通过层层跟踪可以进入到了Node.Start()方法，在start方法中，有一个startRPC方法，启动节点的RPC。
```go
// startRPC is a helper method to configure all the various RPC endpoints during node
// startup. It's not meant to be called at any time afterwards as it makes certain
// assumptions about the state of the node.
func (n *Node) startRPC() error {
    ...
	
    initHttp := func(server *httpServer, port int) error {
    if err := server.setListenAddr(n.config.HTTPHost, port); err != nil {
        return err
    }
    if err := server.enableRPC(openAPIs, httpConfig{
        CorsAllowedOrigins: n.config.HTTPCors,
        Vhosts:             n.config.HTTPVirtualHosts,
        Modules:            n.config.HTTPModules,
        prefix:             n.config.HTTPPathPrefix,
        rpcEndpointConfig:  rpcConfig,
    }); err != nil {
        return err
    }
    servers = append(servers, server)
    return nil
    }
	
	...
}
```

`initHttp`完成了Http RPC服务器的初始化工作。首先设置侦听地址和端口，默认端口8545。然后设置服务器配置信息，包括对外开放的api，http跨域访问，虚拟主机等。设置完成后，将server结构放入到server列表，后续会一一调用start()启动服务。

接下来的流程如下图所示:

<img src="../img/rpc启动流程2.jpg">

其中`server.enableRPC()`传入的第一个参数openAPIs就是对外开放服务的api。通过node.apis()方法获得。来看一下apis()的定义。
```go
// apis返回内置的RPC API集合。
func (n *Node) apis() []rpc.API {
	return []rpc.API{
		{
			Namespace: "admin",
			Service:   &adminAPI{n},
		}, {
			Namespace: "debug",
			Service:   debug.Handler,
		}, {
			Namespace: "web3",
			Service:   &web3API{n},
		},
	}
}

// adminAPI is the collection of administrative API methods exposed over
// both secure and unsecure RPC channels.
type adminAPI struct {
    node *Node // Node interfaced by this API
}

// AddPeer requests connecting to a remote node, and also maintaining the new
// connection at all times, even reconnecting if it is lost.
func (api *adminAPI) AddPeer(url string) (bool, error) {
    // Make sure the server is running, fail otherwise
    server := api.node.Server()
    if server == nil {
        return false, ErrNodeStopped
    }
    // Try to add the url as a static peer and return
    node, err := enode.Parse(enode.ValidSchemes, url)
    if err != nil {
        return false, fmt.Errorf("invalid enode: %v", err)
    }
    server.AddPeer(node)
    return true, nil
}

// Peers retrieves all the information we know about each individual peer at the
// protocol granularity.
func (api *adminAPI) Peers() ([]*p2p.PeerInfo, error) {
    server := api.node.Server()
    if server == nil {
        return nil, ErrNodeStopped
    }
    return server.PeersInfo(), nil
}
```
可以看到，定义了3组API，其中Namespace可认为是API的前缀,一般都是通过`Namespace_方法名`的形式访问。实际上RPC服务的解析过程就是拿到`Namespace_方法名`形式的字符串，然后根据"_"分成两部分，然后从函数映射表中找到`Namespace`路径下的对应的方法地址，执行过程调用返回结果。

Service是接口类型，以`admin`为例，凡是adminAPI类型下的方法，都可以通过Service入口调用，即运行时通过Service的入口，可以找到并执行对应的方法。

比如执行Peers()方法，可以执行
```
curl -XPOST http://localhost:8545 -H 'Content-Type: application/json' -d '{"method": "admin_peers", "params": [], "id":1}'
```

弄清apis的来源后，再来看enableRPC()里面执行了什么。
```go
type rpcHandler struct {
    http.Handler
    server *rpc.Server
}

// enableRPC turns on JSON-RPC over HTTP on the server.
func (h *httpServer) enableRPC(apis []rpc.API, config httpConfig) error {
	h.mu.Lock()
	defer h.mu.Unlock()

	if h.rpcAllowed() {
		return fmt.Errorf("JSON-RPC over HTTP is already enabled")
	}

	// Create RPC server and handler.
	srv := rpc.NewServer()
	srv.SetBatchLimits(config.batchItemLimit, config.batchResponseSizeLimit)
	if err := RegisterApis(apis, config.Modules, srv); err != nil {
		return err
	}
	h.httpConfig = config
	h.httpHandler.Store(&rpcHandler{
		Handler: NewHTTPHandlerStack(srv, config.CorsAllowedOrigins, config.Vhosts, config.jwtSecret),
		server:  srv,
	})
	return nil
}
```
`RegisterApis`将对外服务的api函数名称、地址写进srv内部的映射表。

`httpHandler.Store`是一个原子写入操作，中间不可打断。这一步将`rpcHanlder`地址写入到`httpHandler`中。其中`http.Handler`是一个接口，定义了一个方法`ServeHTTP()`。因为golang支持鸭子类型（即对行为建模），任何实现了这个方法的类型都属于这个接口。只要`NewHTTPHandlerStack`返回的类型实现了ServeHTTP() 方法，就属于这个接口。

`NewHTTPHandlerStack` 实际是创建了一个链表，针对不同http请求的Header信息，用不同的handler处理。

### server.go
`server.go`主要实现了RPC服务端的核心逻辑。 包括RPC方法的注册， 读取请求，处理请求，发送回应等逻辑。 

server的核心数据结构是Server结构体。其中，
- `services`字段是一个结构体，包含了一个map和一个锁，记录了所有注册的方法和类。 
- `run`参数是用来控制Server的运行和停止的。 
- `codecs`是一个set， 用来存储所有的编码解码器，其实就是所有的连接。
- `mutex`是用来保护多线程访问codecs的锁。

`services`字段的value类型是service类型。 service代表了一个注册到Server的实例， 是一个对象和方法的组合。 service字段的name代表了service的namespace， callbacks是实例的回调方法， subscriptions是实例的订阅方法。
```go
// Server is an RPC server.
type Server struct {
	services serviceRegistry
	idgen    func() ID

	mutex              sync.Mutex
	codecs             map[ServerCodec]struct{}
	run                atomic.Bool
	batchItemLimit     int
	batchResponseLimit int
}

type serviceRegistry struct {
    mu       sync.Mutex
    services map[string]service
}

// service represents a registered object.
type service struct {
    name          string               // 服务的名称
    callbacks     map[string]*callback // 已注册的处理程序
    subscriptions map[string]*callback // 可用的订阅/通知
}
```

#### Server的创建
Server创建的时候通过调用server.RegisterName把自己的实例注册上来，提供一些RPC服务的元信息。

调用栈：initHttp()->enableRPC()->rpc.NewSever()->Server.RegisterName()->serviceRegistry.registerName()

```go
// NewServer creates a new server instance with no registered handlers.
func NewServer() *Server {
	server := &Server{
		idgen:  randomIDGenerator(),
		codecs: make(map[ServerCodec]struct{}),
	}
	server.run.Store(true)
	// 注册默认服务，提供有关RPC服务的元信息，例如它提供的服务和方法。
	rpcService := &RPCService{server}
	server.RegisterName(MetadataApi, rpcService)
	return server
}
```

服务注册`server.RegisterName`，`RegisterName`方法会通过传入的参数来创建一个service对象，如果传入的receiver实例没有找到任何合适的方法，那么会返回错误。 如果没有错误，就把创建的service实例加入serviceRegistry。  
执行流程：
1. 首先，使用了golang的反射，reflect.ValueOf()是运行时动态获取接口rcvr具体值。
2. 调用`suitableCallbacks`进行合法性检查，检查rcvrVal的值是不是符合callback函数的要求。
3. 从`r.mu.Lock()`开始，构建映射表，因为golang的map不是协程安全的，因此操作前要加锁。然后创建方法映射表。这里name="rpc"，函数`callbacks` 从 `suitableCallbacks()`中解析而出。
```go
// RegisterName函数会根据给定的名称和接收器类型创建一个服务。
// 当给定接收器没有匹配到符合RPC方法或订阅的条件时，函数会返回一个错误。
// 否则，函数会创建一个新的服务并将其添加到该服务器提供给客户端的服务集合中。
func (s *Server) RegisterName(name string, receiver interface{}) error {
	return s.services.registerName(name, receiver)
}

func (r *serviceRegistry) registerName(name string, rcvr interface{}) error {
    rcvrVal := reflect.ValueOf(rcvr)
    if name == "" {
        return fmt.Errorf("no service name for type %s", rcvrVal.Type().String())
    }
    callbacks := suitableCallbacks(rcvrVal)
    if len(callbacks) == 0 {
        return fmt.Errorf("service %T doesn't have any suitable methods/subscriptions to expose", rcvr)
    }
    
    r.mu.Lock()
    defer r.mu.Unlock()
    if r.services == nil {
        r.services = make(map[string]service)
    }
    // 如果这个名字当前没有被注册过，那么直接初始化并插入。
    svc, ok := r.services[name]
    if !ok {
        svc = service{
            name:          name,
            callbacks:     make(map[string]*callback),
            subscriptions: make(map[string]*callback),
        }
        r.services[name] = svc
    }
    for name, cb := range callbacks {
        if cb.isSubscribe {
            svc.subscriptions[name] = cb
        } else {
            svc.callbacks[name] = cb
        }
    }
    return nil
}
```

再来看`suitableCallbacks()`方法：
1. `suitableCallbacks` 首先获取receiver的类型，应该是`*RPCService`类型（RPCService的指针）。
2. 接着遍历`*RPCService`的类型定义的方法，根据源代码实现，这个类型只有一个方法即`Modules()`，定义在`rpc/server.go`中。对`*RPCService`每个方法，做合法性检查，然后将method对应的方法转换成一个callback对象赋值给cb。
3. formatName将首字母变成小写，然后加入到callback映射表。

```go
// suitableCallbacks函数会遍历给定类型的方法。
// 它会确定一个方法是否满足RPC回调或订阅回调的条件，并将其添加到回调集合中。
func suitableCallbacks(receiver reflect.Value) map[string]*callback {
    typ := receiver.Type()
    callbacks := make(map[string]*callback)
    for m := 0; m < typ.NumMethod(); m++ {
        method := typ.Method(m)
        if method.PkgPath != "" {
            continue // method not exported
        }
		// 将fn（一个函数）转换为一个回调对象。如果该函数不适合作为RPC回调，则返回nil。
        cb := newCallback(receiver, method.Func)
        if cb == nil {
            continue // function invalid
        }
        name := formatName(method.Name)
        callbacks[name] = cb
    }
    return callbacks
}
```

回到enableRPC()，完成一个RPCServer结构创建后，会执行`RegisterApis`，将对外开放的API方法（`apis()`）写入到映射表中，在服务运行时，根据请求参数查表执行对应的服务API。具体来看`RegisterApis`：
1. 检查Module的可用性
2. 根据开放的模块（namespace？）设置开放列表，这个参数可以通过命令行传递，启动时指定Geth节点开放哪些模块的RPC服务。
3. 对于每个`rpc.API`结构体，满足开放条件的话，就写入到映射列表。其中名字是Namesapce定义的名字，`api.Service`是前面提到的接口。RegietgerName里面会利用反射机制，遍历每个api.Service结构拥有的方法，将方法名和入口地址写入到映射表（方法名第一个字母小写）。

再回顾前面给出的例子。这里就理解了为什么`admin` Namespace空间下，类型`adminAPI` 拥有的方法`func (api *adminAPI) Peers() ([]*p2p.PeerInfo, error)` ，在RPC调用下，传入的参数是`admin_peers`了。
```go
// RegisterApis检查给定模块的可用性，基于允许的模块生成一个允许列表，然后注册所有由服务暴露的API。
func RegisterApis(apis []rpc.API, modules []string, srv *rpc.Server) error {
	if bad, available := checkModuleAvailability(modules, apis); len(bad) > 0 {
		log.Error("Unavailable modules in HTTP API list", "unavailable", bad, "available", available)
	}
	// 根据允许的模块生成允许列表。
	allowList := make(map[string]bool)
	for _, module := range modules {
		allowList[module] = true
	}
	// 注册所有由服务暴露的API。
	for _, api := range apis {
		if allowList[api.Namespace] || len(allowList) == 0 {
			if err := srv.RegisterName(api.Namespace, api.Service); err != nil {
				return err
			}
		}
	}
	return nil
}
```

#### server启动和服务
完成设置后，启动HTTP 服务，先给出设置完服务RPC服务后，启动服务的流程框图。

<img src="../img/rpc-启动HTTP服务.jpg">

启动Http服务：rpcstack.go/start()
```go
// start starts the HTTP server if it is enabled and not already running.
func (h *httpServer) start() error {
	h.mu.Lock()
	defer h.mu.Unlock()

	if h.endpoint == "" || h.listener != nil {
		return nil // already running or not configured
	}

	// Initialize the server.
	h.server = &http.Server{Handler: h}
	if h.timeouts != (rpc.HTTPTimeouts{}) {
		CheckTimeouts(&h.timeouts)
		h.server.ReadTimeout = h.timeouts.ReadTimeout
		h.server.ReadHeaderTimeout = h.timeouts.ReadHeaderTimeout
		h.server.WriteTimeout = h.timeouts.WriteTimeout
		h.server.IdleTimeout = h.timeouts.IdleTimeout
	}

	// Start the server.
	listener, err := net.Listen("tcp", h.endpoint)
	if err != nil {
		// If the server fails to start, we need to clear out the RPC and WS
		// configuration so they can be configured another time.
		h.disableRPC()
		h.disableWS()
		return err
	}
	h.listener = listener
	go h.server.Serve(listener)

	if h.wsAllowed() {
		url := fmt.Sprintf("ws://%v", listener.Addr())
		if h.wsConfig.prefix != "" {
			url += h.wsConfig.prefix
		}
		h.log.Info("WebSocket enabled", "url", url)
	}
	// if server is websocket only, return after logging
	if !h.rpcAllowed() {
		return nil
	}
	// Log http endpoint.
	h.log.Info("HTTP server started",
		"endpoint", listener.Addr(), "auth", (h.httpConfig.jwtSecret != nil),
		"prefix", h.httpConfig.prefix,
		"cors", strings.Join(h.httpConfig.CorsAllowedOrigins, ","),
		"vhosts", strings.Join(h.httpConfig.Vhosts, ","),
	)

	// Log all handlers mounted on server.
	var paths []string
	for path := range h.handlerNames {
		paths = append(paths, path)
	}
	sort.Strings(paths)
	logged := make(map[string]bool, len(paths))
	for _, path := range paths {
		name := h.handlerNames[path]
		if !logged[name] {
			log.Info(name+" enabled", "url", "http://"+listener.Addr().String()+path)
			logged[name] = true
		}
	}
	return nil
}
```

server的启动和服务这里参考ipc.go中的一部分代码。可以看到每`Accept()`一个链接，就启动一个goroutine调用`srv.ServeCodec`来进行服务，这里也可以看出JsonCodec的功能，Codec类似于装饰器模式，在连接外面包了一层。
```go
// ServeListener函数在l上接受连接，为它们提供JSON-RPC服务。
func (s *Server) ServeListener(l net.Listener) error {
	for {
		conn, err := l.Accept()
		if netutil.IsTemporaryError(err) {
			log.Warn("RPC accept error", "err", err)
			continue
		} else if err != nil {
			return err
		}
		log.Trace("Accepted RPC connection", "conn", conn.RemoteAddr())
		go s.ServeCodec(NewCodec(conn), 0)
	}
}
```

`ServeCodec` 这个方法很简单，提供了codec.Close的关闭功能。 ~~serveRequest的第二个参数singleShot是控制长连接还是短连接的参数，如果singleShot为真，那么处理完一个请求之后会退出。 不过咱们的serveRequest方法是一个死循环，不遇到异常，或者客户端主动关闭，服务端是不会关闭的。 所以rpc提供的是长连接的功能。~~
```go
// ServeCodec函数从codec读取传入的请求，调用适当的回调函数，并使用给定的codec将响应写回。
// 它会阻塞，直到codec关闭或服务器停止。
// 在任一情况下，codec都会被关闭。
// 请注意，不再支持codec选项。
func (s *Server) ServeCodec(codec ServerCodec, options CodecOption) {
	defer codec.close()

	if !s.trackCodec(codec) {
		return
	}
	defer s.untrackCodec(codec)

	cfg := &clientConfig{
		idgen:              s.idgen,
		batchItemLimit:     s.batchItemLimit,
		batchResponseLimit: s.batchResponseLimit,
	}
	c := initClient(codec, &s.services, cfg)
	<-codec.closed()
	c.Close()
}
```

~~我们的重磅方法终于出场，serveRequest 这个方法就是Server的主要处理流程。从codec读取请求，找到对应的方法并调用，然后把回应写入codec。~~
这部分没看懂，待研究

#### subscription.go 发布订阅模式
















