fetcher包含基于块通知的同步。当我们接收到`NewBlockHashesMsg`消息得时候，我们只收到了很多Block的hash值。 需要通过hash值来同步区块，然后更新本地区块链。 fetcher就提供了这样的功能。

## 数据结构
```go
// blockAnnounce is the hash notification of the availability of a new block in the
// network.
type blockAnnounce struct {
	hash   common.Hash   // 被宣布的区块的哈希值
	number uint64        // 被宣布的区块的编号（0 = 未知 | 旧协议）
	header *types.Header // 部分重新组装的区块头（新协议）
	time   time.Time     // 宣布的时间戳

	origin string // 发出通知的对等方标识符

	fetchHeader headerRequesterFn // 用于获取宣布的区块头的获取函数
	fetchBodies bodyRequesterFn   // 用于获取宣布的区块体的获取函数
}

// 表示一批需要过滤的区块头。
type headerFilterTask struct {
	peer    string          // 区块头的源对等方
	headers []*types.Header // 需要过滤的区块头集合
	time    time.Time       // 区块头的到达时间
}

// 表示一批需要过滤的区块体（交易和叔块）。
type bodyFilterTask struct {
	peer         string                 // 区块体的源对等方
	transactions [][]*types.Transaction // 每个区块体的交易集合
	uncles       [][]*types.Header      // 每个区块体的叔叔块集合
	time         time.Time              // 区块内容的到达时间
}

// 表示一个计划的导入操作。
type blockOrHeaderInject struct {
	origin string

	header *types.Header // 用于轻模式的获取器，只关注区块头。
	block  *types.Block  // 用于正常模式的获取器，导入完整的区块。
}

// 负责从各个对等方累积区块的宣告，并安排它们进行检索。
type BlockFetcher struct {
    light bool // 指示是否为轻量级获取器或正常获取器的指标。
    
    // 各种事件通道
    notify chan *blockAnnounce
    inject chan *blockOrHeaderInject
    
    headerFilter chan chan *headerFilterTask
    bodyFilter   chan chan *bodyFilterTask
    
    done chan common.Hash
    quit chan struct{}
    
    // Announce states
    announces  map[string]int                   // 每个对等方的区块宣告计数，以防止内存耗尽
    announced  map[common.Hash][]*blockAnnounce // 已宣告的区块，计划进行获取
    fetching   map[common.Hash]*blockAnnounce   // 正在获取的已宣告的区块
    fetched    map[common.Hash][]*blockAnnounce // 已获取区块头的区块，计划进行区块体获取
    completing map[common.Hash]*blockAnnounce   // 具有区块头的区块，正在完成区块体
    
    // Block cache
    queue  *prque.Prque[int64, *blockOrHeaderInject] // 包含导入操作的队列（按区块编号排序）
    queues map[string]int                            // 每个对等方的区块计数，以防止内存耗尽
    queued map[common.Hash]*blockOrHeaderInject      // 已排队的区块集合（用于去重导入）
    
    // Callbacks
    getHeader      HeaderRetrievalFn  // 从本地链中检索区块头
    getBlock       blockRetrievalFn   // 从本地链中检索区块
    verifyHeader   headerVerifierFn   // 检查区块的区块头是否具有有效的工作证明
    broadcastBlock blockBroadcasterFn // 向连接的对等方广播一个区块
    chainHeight    chainHeightFn      // 检索当前链的高度
    insertHeaders  headersInsertFn    // 向链中注入一批区块头
    insertChain    chainInsertFn      // 向链中注入一批区块
    dropPeer       peerDropFn         // 因对等方行为不端而断开连接
    
    // Testing hooks
    announceChangeHook func(common.Hash, bool)           // 在添加或删除区块哈希到区块宣告列表时调用的方法
    queueChangeHook    func(common.Hash, bool)           // 在添加或删除区块到导入队列时调用的方法
    fetchingHook       func([]common.Hash)               // 在开始区块（eth/61）或区块头（eth/62）获取时调用的方法
    completingHook     func([]common.Hash)               // 在开始区块体获取（eth/62）时调用的方法
    importedHook       func(*types.Header, *types.Block) // 在成功导入区块头或区块（eth/61和eth/62）时调用的方法
}
```

## 启动fetche
直接启动了一个goroutine来处理。 这个函数有点长。 后续再分析。
```go
// start函数启动基于宣告的同步器，接受和处理哈希通知和区块获取，直到请求终止为止。
func (f *BlockFetcher) Start() {
	go f.loop()
}
```

loop函数函数太长。 我先帖一个省略版本的出来。fetcher通过四个map(announced,fetching,fetched,completing )记录了announce的状态(等待fetch,正在fetch,fetch完头等待fetch body, fetch完成)。 loop其实通过定时器和各种消息来对各种map里面的announce进行状态转换。
```go
// Loop is the main fetcher loop, checking and processing various notification
// events.
func (f *BlockFetcher) loop() {
	// Iterate the block fetching until a quit is requested
	var (
		fetchTimer    = time.NewTimer(0)
		completeTimer = time.NewTimer(0)
	)
	<-fetchTimer.C // clear out the channel
	<-completeTimer.C
	defer fetchTimer.Stop()
	defer completeTimer.Stop()

	for {
		// Clean up any expired block fetches
		for hash, announce := range f.fetching {
			if time.Since(announce.time) > fetchTimeout {
				f.forgetHash(hash)
			}
		}
		// Import any queued blocks that could potentially fit
		height := f.chainHeight()
		for !f.queue.Empty() {
			op := f.queue.PopItem()
			hash := op.hash()
			if f.queueChangeHook != nil {
				f.queueChangeHook(hash, false)
			}
			// If too high up the chain or phase, continue later
			number := op.number()
			if number > height+1 {
				f.queue.Push(op, -int64(number))
				if f.queueChangeHook != nil {
					f.queueChangeHook(hash, true)
				}
				break
			}
			// Otherwise if fresh and still unknown, try and import
			if (number+maxUncleDist < height) || (f.light && f.getHeader(hash) != nil) || (!f.light && f.getBlock(hash) != nil) {
				f.forgetBlock(hash)
				continue
			}
			if f.light {
				f.importHeaders(op.origin, op.header)
			} else {
				f.importBlocks(op.origin, op.block)
			}
		}
		// Wait for an outside event to occur
		select {
		case <-f.quit:
			// BlockFetcher terminating, abort all operations
			return

		case notification := <-f.notify: // 在接收到NewBlockHashesMsg的时候，对于本地区块链还没有的区块的hash值会调用fetcher的Notify方法发送到notify通道。
			...

		case op := <-f.inject: // 在接收到NewBlockMsg的时候会调用fetcher的Enqueue方法，这个方法会把当前接收到的区块发送到inject通道。
			...

		case hash := <-f.done: // 当完成一个区块的import的时候会发送该区块的hash值到done通道。
			...

		case <-fetchTimer.C: // fetchTimer定时器，定期对需要fetch的区块头进行fetch
			...

		case <-completeTimer.C: // completeTimer定时器定期对需要fetch的区块体进行fetch
			...

		case filter := <-f.headerFilter: // 当接收到BlockHeadersMsg的消息的时候(接收到一些区块头),会把这些消息投递到headerFilter队列。 这边会把属于fetcher请求的数据留下，其他的会返回出来，给其他系统使用。
			...

		case filter := <-f.bodyFilter: // 当接收到BlockBodiesMsg消息的时候，会把这些消息投递给bodyFilter队列。这边会把属于fetcher请求的数据留下，其他的会返回出来，给其他系统使用。
			...
		}
	}
}
```

### 区块头的过滤流程
#### FilterHeaders请求
FilterHeaders方法在接收到BlockHeadersMsg的时候被调用。这个方法首先投递了一个channel filter到headerFilter。 然后往filter投递了一个headerFilterTask的任务。然后阻塞等待filter队列返回消息。
```go
// FilterHeaders extracts all the headers that were explicitly requested by the fetcher,
// returning those that should be handled differently.
func (f *BlockFetcher) FilterHeaders(peer string, headers []*types.Header, time time.Time) []*types.Header {
	log.Trace("Filtering headers", "peer", peer, "headers", len(headers))

	// Send the filter channel to the fetcher
	filter := make(chan *headerFilterTask)

	select {
	case f.headerFilter <- filter:
	case <-f.quit:
		return nil
	}
	// Request the filtering of the header list
	select {
	case filter <- &headerFilterTask{peer: peer, headers: headers, time: time}:
	case <-f.quit:
		return nil
	}
	// Retrieve the headers remaining after filtering
	select {
	case task := <-filter:
		return task.headers
	case <-f.quit:
		return nil
	}
}
```

#### headerFilter的处理
这个处理在loop()的goroutine中。
```go
       case filter := <-f.headerFilter:
		// Headers arrived from a remote peer. Extract those that were explicitly
		// requested by the fetcher, and return everything else so it's delivered
		// to other parts of the system.
		var task *headerFilterTask
		select {
		case task = <-filter:
		case <-f.quit:
			return
		}
		headerFilterInMeter.Mark(int64(len(task.headers)))
		// Split the batch of headers into unknown ones (to return to the caller),
		// known incomplete ones (requiring body retrievals) and completed blocks.
		unknown, incomplete, complete, lightHeaders := []*types.Header{}, []*blockAnnounce{}, []*types.Block{}, []*blockAnnounce{}
		for _, header := range task.headers {
			hash := header.Hash()
			// Filter fetcher-requested headers from other synchronisation algorithms
			if announce := f.fetching[hash]; announce != nil && announce.origin == task.peer && f.fetched[hash] == nil && f.completing[hash] == nil && f.queued[hash] == nil {
				// If the delivered header does not match the promised number, drop the announcer
				if header.Number.Uint64() != announce.number {
					log.Trace("Invalid block number fetched", "peer", announce.origin, "hash", header.Hash(), "announced", announce.number, "provided", header.Number)
					f.dropPeer(announce.origin)
					f.forgetHash(hash)
					continue
				}
				// Collect all headers only if we are running in light
				// mode and the headers are not imported by other means.
				if f.light {
					if f.getHeader(hash) == nil {
						announce.header = header
						lightHeaders = append(lightHeaders, announce)
					}
					f.forgetHash(hash)
					continue
				}
				// Only keep if not imported by other means
				if f.getBlock(hash) == nil {
					announce.header = header
					announce.time = task.time
					// If the block is empty (header only), short circuit into the final import queue
					if header.TxHash == types.EmptyTxsHash && header.UncleHash == types.EmptyUncleHash {
						log.Trace("Block empty, skipping body retrieval", "peer", announce.origin, "number", header.Number, "hash", header.Hash())
						block := types.NewBlockWithHeader(header)
						block.ReceivedAt = task.time
						complete = append(complete, block)
						f.completing[hash] = announce
						continue
					}
					// Otherwise add to the list of blocks needing completion
					incomplete = append(incomplete, announce)
				} else {
					log.Trace("Block already imported, discarding header", "peer", announce.origin, "number", header.Number, "hash", header.Hash())
					f.forgetHash(hash)
				}
			} else {
				// BlockFetcher doesn't know about it, add to the return list
				unknown = append(unknown, header)
			}
		}
		headerFilterOutMeter.Mark(int64(len(unknown)))
		select {
		case filter <- &headerFilterTask{headers: unknown, time: task.time}:
		case <-f.quit:
			return
		}
		// Schedule the retrieved headers for body completion
		for _, announce := range incomplete {
			hash := announce.header.Hash()
			if _, ok := f.completing[hash]; ok {
				continue
			}
			f.fetched[hash] = append(f.fetched[hash], announce)
			if len(f.fetched) == 1 {
				f.rescheduleComplete(completeTimer)
			}
		}
		// Schedule the header for light fetcher import
		for _, announce := range lightHeaders {
			f.enqueue(announce.origin, announce.header, nil)
		}
		// Schedule the header-only blocks for import
		for _, block := range complete {
			if announce := f.completing[block.Hash()]; announce != nil {
				f.enqueue(announce.origin, nil, block)
			}
		}
```
































































