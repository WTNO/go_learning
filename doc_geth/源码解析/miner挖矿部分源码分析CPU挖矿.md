## ~~agent.go~~
~~agent 是具体执行挖矿的对象。 它执行的流程就是，接受计算好了的区块头， 计算mixhash和nonce， 把挖矿好的区块头返回。~~

~~构造CpuAgent, 一般情况下不会使用CPU来进行挖矿，一般来说挖矿都是使用的专门的GPU进行挖矿， GPU挖矿的代码不会在这里体现~~

> agent.go在当前版本已被删除，需要重新研究一下代码

## ~~remote_agent~~
~~remote_agent 提供了一套RPC接口，可以实现远程矿工进行采矿的功能。 比如我有一个矿机，矿机内部没有运行以太坊节点，矿机首先从remote_agent获取当前的任务，然后进行挖矿计算，当挖矿完成后，提交计算结果，完成挖矿。~~

> agent.go在当前版本已被删除，需要重新研究一下代码

# 1. 挖矿
下图是以太坊挖矿的主要环节，一环扣一环，缺一不可。

<img src="../img/挖矿主要环节.webp">

以太坊 geth 项目中，关于挖矿逻辑，全部在 miner 包中，3个文件便清晰滴定义挖矿逻辑。所以，后面讲解挖矿业主要集中在这几个文件中。

## 开启挖矿
在以太坊控制台，只需要输入命令：miner.start()即可进开启实时挖矿。 能否能挖新新区，取决于交易池是否有交易和服务器性能。

## 构建新区块
挖矿过程实际就是创建一个符合共识的新区块过程。所以在开启挖矿后，矿工的第一件事情则是集中完成一个新区块的构建，为后续挖矿过程做准备。

## POW寻找Nonce
以太坊本是基于POW工作量证明的共识算法。在这里必须找出一个通过哈希计算，在约定时间内找出一个符合难度值的Nonce。找到相符的Nonce，表示进行了一定的工作量计算。 这是所有POW共识的区块链所必须经历的一个挖矿流程。

## 挖矿成功
并不是一定能成功找出Nonce。特别是在规定的时间内和别人已挖出该高度区块时。只有成功找出Nonce后，则可以大胆的告诉所有人，我已经挖出这个高度的区块了。可以理直气壮地将此区块保留到本地，并广播到整个网络。

## 本次存储新区块
一旦成功挖出新区块，则可以直接将其存储到本地。存储后，可以等待别人对他的认可度。一旦超过50%的节点认可后，大概率上你这个新区块将作为最长链的一部分。

## 网络广播新区块
如何让别人能快速认可你的区块，所以需要在第一时间将区块广播到网络中。抢先于别人一秒，将增大新区块的被认可度。

# 2. 以太坊挖矿架构设计
以太坊 geth 项目中，关于挖矿逻辑，全部在 miner 包中，仅用3个文件便清晰滴定义挖矿逻辑。上一篇文章中，可以看到挖矿的主要环节也就几个。但是如何协商每个环节的处理，却在于架构设计。本文先同大家讲解以太坊关于挖矿的架构设计。

<img src="../img/挖矿架构设计.webp">

> 当前版本有所变化

上图是以太坊 Miner 包中关于挖矿的核心结构。对外部仅仅开放了 Miner 对象，注意：
1. 任何对挖矿的操作均通过 Miner 对象操作
2. 实际挖矿细节全部在 worker 实例中实现
3. 将关键核心数据存储在 environment 中。

外部只需通过调用 Start、Stop 即可完成启动和停止挖矿。当然也可修改一些挖矿参数，如区块头中的可自定义数据 Extra，以及随时调用 SetEtherebase 修改矿工地址 coinbase。

这个的核心全部在 worker 中，worker 是一个工作管理器。订阅了 blockchain 的三个事件，分别监听
1. 新区块事件 chainHeadeCh
2. 新分叉链事件 chainSideCh
3. 新交易事件txCh
4. 以及定义了内部一系列的信号，如 newWork 信号、task信号等。根据信号，执行不同的工作，在各种信号综合作用下协同作业。

在创建worker 时，将在 worker 内开启四个 goroutine 来分别监听不同信号。

<img src="../img/worker信号.webp">

首先是 mainLoop ，将监听 newWork 、tx、chainSide 信号。

- newWork:表示将开始挖采下一个新区块。这个信号在需要重新挖矿时发出，而此信号来自于 newWorkLoop 。当收到newWork信号，矿工将立刻将当前区块作为父区块，来挖下一个区块。

- 当收到来自交易池的tx信号时，如果已经是挖矿中，则可以忽略这些交易。因为交易一样会被矿工从交易池主动拿取。如果尚未开始挖矿，则有机会将交易暂时提交，并更新到state中。

同样，当 blockchain 发送变化（新区块）时，而自己当下的挖掘块中仅有极少的叔块，此时允许不再处理交易，而是直接将此叔块加入，立刻提交当前挖掘块。

newWorkLoop 负责根据不同情况来抉择是否需要终止当前工作，或者开始新一个区块挖掘。有以下几种情况将会终止当前工作，开始新区块挖掘。
1. 接收到 start 信号，表示需要开始挖矿。
2. 接收到 chainHeadCh 新区块信号，表示已经有新区块出现。你所处理的交易或者区块高度都极有可能重复，需要终止当下工作，立即开始新一轮挖矿。
3. timer计时器，默认每三秒检查一次是否有新交易需要处理。如果有则需要重新开始挖矿。以便将加高的交易优先打包到区块中。

在 newWorkLoop 中还有一个辅助信号，resubmitAdjustCh 和 resubmitIntervalCh。运行外部修改timer计时器的时钟。resubmitAdjustCh是根据历史情况重新计算一个合理的间隔时间。而resubmitIntervalCh则允许外部，实时通过 Miner 实例方法 SetRecommitInterval 修改间隔时间。

上面是在控制何时挖矿，而 taskLoop 和resultLoop则不同。 taskLoop 是在监听任务。任务是指包含了新区块内容的任务，表示可以将此新区块进行PoW计算。一旦接受到新任务，则立即将此任务进行PoW工作量计算，寻找符合要求的Nonce。一旦计算完成，把任务和计算结果作为一项结果数据告知 resultLoop 。由resultLoop 完成区块的最后工作，即将计算结构和区块基本数据组合成一个符合共识算法的区块。完成区块最后的数据存储和网络广播。

同时，在挖矿时将当下的挖矿工作的过程信息记录在 environment 中，打包区块时只需要从当前的environment中获取实时数据，或者快照数据。

采用goroutine下使用 channel 作为信号，以太坊 miner 完成一个激活挖矿到最终挖矿成功的整个逻辑。上面的讲解不涉及细节，只是让大家对挖矿有一个整体了解。为后续的各环节详解做准备。









































