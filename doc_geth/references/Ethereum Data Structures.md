# Ethereum Data Structures
### KAMIL JEZEK, University of Sydney
以太坊平台运作时使用了丰富的数据结构、哈希和编码函数。主要的参考资料是黄皮书，此外还有很多非正式的博客。这些资料在某种程度上存在一定的限制。特别是黄皮书在简洁性和详细性之间没有达到理想的平衡，在某些部分过于详细，而在其他部分则过于浅显。而博客则常常过于模糊，有时还包含错误信息。为解决这个问题，我们提供了这份文档，总结了以太坊中使用的数据结构。目标是在保持简洁性的同时提供足够的详细信息。充分详细的正式视图通过示例来增强清晰度。

CCS概念：
- 通用与参考 → 调查和概述；
- 计算机系统组织 → 对等体系结构；
- 软件及其工程 → 虚拟机；对等体系结构；完整性；数据类型和结构；
- 计算理论 → 数据压缩；排序和搜索。

附加关键词和短语：以太坊、区块链、数据结构、Merkle、Patricia、树

## <font color="#5395ca">1.介绍</font>
区块链服务器作为一个自动分布式账本，包括所有的交易和状态。当区块链中的区块被执行时，它会不断修改状态，改变账户余额，生成交易收据等。这个系统是不停止的，接受新的交易，创建新的区块，不断增长状态。为了处理这种复杂性，尤其是不断增长的数据量，区块链架构师重新利用了计算机科学历史上已知的基本数据结构，但以新的形式组合它们。

由于区块链平台中使用的数据结构有时很复杂，有时只适用于以太坊，因此了解它们以能够理解平台本身非常重要。这对于希望扩展、修改、构建、进行研究等以太坊的研究人员和从业者尤为重要。在这个领域，存在两个主要的知识来源，第一个是官方文件，如黄皮书[49]，另一个是无尽的互联网博客。

我们认为，与数据结构特别相关的信息来源是有限的。合理的出版物涵盖了区块链和以太坊作为一个平台的更广泛的视角。让我们提到Kolb等人的工作[29]。他的工作向初学者介绍了区块链，涵盖了我们不涉及的挖矿、激励等方面，并比较了各种区块链平台。然而，当涉及到数据结构时，它相对肤浅，提供的细节不如在线博客。Lao等人[30]或Zhu等人[54]提供了更广泛的视角。这两篇论文都在有限的程度上概述了区块链的结构。从安全角度来看，张等人[53]讨论了区块链平台。

两篇学生论文，一篇是由Voulgari [48]撰写的，另一篇是由Hefele [19]撰写的，它们都详细描述了以太坊数据结构。特别是Hefele的工作非常相关，他使用UML图表对以太坊数据结构进行建模。根据我们的判断，这可能会在复杂的以太坊数据结构中带来清晰度。然而，这两篇论文只是将数据结构描述为分析存储在这些结构中的数据量的手段，本身并没有描述这些结构到展示数据如何在内存或磁盘中编码的程度。

Antonopoulos和Wood，以太坊的创始人，在他们的书[4]中提供了丰富的信息，或者在Bashir的另一本书[5]中也有。这两本出版物似乎主要面向以太坊的最终用户，因为它们详细介绍了所有周围的工具，但没有深入研究内部结构。

综上所述，唯一详尽的信息来源是黄皮书[49]。我们认为这本出版物并不理想，无法理解以太坊的数据结构。特别是，它将信息分散在出版物的附录中，有关数据编码的细节有时不清楚其与部分部分的关系。此外，这本出版物省略了智能合约数据在内存槽中的结构和存储信息。虽然他们这样做是有意的，因为数据格式留给了智能合约编译器，但我们认为这部分对于理解以太坊的数据组织至关重要。因此，我们还研究了Solidity编译器，以提供数据格式，并在本出版物中进行总结。

为了填补黄皮书各个部分缺失或不清晰的信息，我们不得不依赖于互联网博客。然而，它们的问题在于质量差异很大，因为它们更多地反映了人们的理解。为了应对这个限制，在某些情况下，我们不得不查阅以太坊客户端的源代码实现，即Parity[47]和Geth[15]，以确认某些细节。我们的目标是提供足够的细节，避免不必要的正式方法，就像黄皮书中的情况一样，但我们的目标是使用比许多博客提供的更好的细节。为了增加清晰度，我们提供了大量的例子和插图。

本论文的范围仅限于以太坊中使用的数据结构。我们不会详细讨论诸如区块挖掘、验证、执行、智能合约创建等领域。然而，在某些情况下，我们也会提及这些领域，以支持对数据结构的解释。

本文的结构如下所示。首先描述了基本数据结构，然后阐述了以Merkle Patricia Trie形式扩展这些结构。之后提供了区块的结构，接下来详细介绍了用于以太坊数据表示的Trie结构。

## <font color="#5395ca">2.TREES AND TRIES</font>
区块链平台需要从底层数据源中查找大量的密钥。由于分布式的性质，它们还需要具备可信赖性。因此，区块链平台试图采用高效的搜索和加密算法。它们主要使用和扩展以下章节中提到的数据结构。

### <font color="#5395ca">2.1 Search Trees</font>
树是一种有效搜索的标准方法之一。它们有各种形式，其中一些在Knuth的著名书籍《计算机程序设计艺术》第3卷[27]中有描述，其中在第6.2.2节中描述了一个非常常见的二叉搜索树。

二叉搜索树可以形成一个前缀树，其中具有相同前缀的键共享从根到叶子的相同路径。在这样的树中搜索键时，键从第一个字符迭代到最后一个字符，并且对于每个字符，检查树中是否存在与该字符匹配的子节点。树的遍历下降到子节点，选择下一个字符，并重复相同的步骤。

让我们详细讨论一下树的二进制编码算法。在这种情况下，每个节点可以根据二进制的0或1分支到左侧或右侧。所有可能的有效键都可以以其二进制形式存储在这样的键中。节点由根到子节点组成，以表示存储在此树中的所有键，对于每个节点，左侧或右侧分支以在键中的当前位置编码二进制的1和0。图3（左侧）显示了这样一个前缀树的示例。它编码了四个二进制键（作为图例显示）。这些键形成了从根节点到叶子点的四条路径（着色节点）。与示例中的键相反，诸如100、101之类的备选键在此树中没有编码，因为没有从根到叶子节点表示它们的路径。

这种数据结构在键经常具有相同前缀的数据中具有节省内存的好处。例如，存储IP4地址，因为这些地址对于相同的IP段具有相同的前缀。例如，IP4 CIDR块 192.168.56.0/30 包含一个始终相同且仅在剩余的2位上有所不同的30位值。在这种情况下，将该网络的所有可能主机（实际上只有四个可能的主机）存储在前缀树中是有效的。前缀树将需要 $30 + 2^2 = 34$ bits，而独立存储每个地址将需要 $32 × 2^2 = 128$ bits。

### <font color="#5395ca">2.2 Patricia Trie</font>
搜索树的明显缺点是，当没有分支时（即节点只有一个子节点），它必须通过多个子节点进行下降。例如，在图3的示例中，需要遍历两个节点才能重构所有以'11'为前缀的键。尽管示例展示了一个简单的二叉树，但对于N叉树同样存在这个问题。总会出现只有一个分支存在的情况。当键具有长的共同部分时，问题会增加，因为它在树中创建了长的单分支路径。

为了解决这个问题，Fredkin在他的论文[16]中提出了Trie Memory。他将这种新结构称为Trie，因为它用于信息检索。他将数据表示为一个表格，其中表格的列是节点，行是分支。行数取决于分支的数量。例如，表示二进制数据需要两行。相反，表示十六进制字符串需要0到F行。列数根据分支数量而变化。如果相同的数据在树中表示，那么树的深度等于列数。

这个表格的每个单元格可以包含一个子节点的引用或一个字符串。对于子节点的引用通过跳转到一个列的编号来表示。如果存储了字符串，那么它等价于键的后缀。它还终止了当前路径。

查找从输入键通过字符遍历开始。首先在行中找到当前位置的字符。如果该行包含一个字符串，该路径终止，并找到一个键。如果单元格包含指向另一个节点的链接（即另一列），则该列包含所有编码键的所有可能分支。要找到特定的键，需要取下一个输入键的字符，并找到与该字符匹配的行。这行与当前列确定了一个表格单元格。再次分析该单元格，并进行递归算法。如果单元格为空（即既没有下一列也没有字符串），则输入键未编码在表格中。

图1展示了一个内存Trie的示例，其中编码了四个具有十六进制字符的键。所有键的前四个字符（一个数字'1'）都是相同的。因此，前四列只是指向下一列。

<img src="../img/Fig1.PNG"/>

然后分叉发生，即标记为‘5’的列包含对列‘6’、‘7’和‘8’的引用。列‘5’本身表示各行中键的下一个字符 - 行‘0’、‘2’和‘F’对应所有编码键中的第五个字符。最后，列‘6,7,8’包含键的后缀，因为不再需要分叉。

这种数据结构在速度方面非常有效，因为它可以表示为二维数组，并且可以通过该数组中的索引进行访问。另一方面，它具有很大的内存开销，尤其是当结构稀疏时。这个问题可以通过像Briandais [10]提出的将路径表示为链表来解决，这样一个节点的所有可能分支都被表示为树，从而组成了所有节点的Trie森林。

原始Trie结构的另一个缺点是它仅仅分组键的公共后缀。换句话说，它加快了以相同后缀结尾的键的查找速度。当然，具有相同前缀的键的数据集也可以简单地通过以相反顺序保存数据来建模。然而，这并没有解决键在一般情况下趋向于具有共同路径（在键的中间）的情况。

Morrison在他的名为“编码为字母数字的实用检索信息算法”的工作中（即Patricia）解决了这个缺点。这种结构是使用一种更多优化的Trie。每个节点包含一定数量的位，当匹配一个键时，可以跳过这些位，因为数据集中的所有键都具有相同的路径。当跳过了这些位时，树会根据下一个位向左或向右分支。

图3中的示例在右侧可视化了一个Patricia Trie。数据集中的所有键都以11开头，因此可以跳过两个位（我们将其可视化为从根节点出发的标记为11的边）。因此，分叉从键的第三位开始。键的后缀11和110也被分组，但这已经是原始Trie设计的一个特点，我们在这里只是将其可视化为树而不是表格。

需要注意的是，Patricia Trie最初是为二叉树提出的，但现在实际上用于N叉树。例如，可以轻松地将图1中的示例表示为Patricia格式。在图2中进行了可视化，其中元组“4(5)”表示在访问列‘5’之前，已经跳过了四列（即相同的字符）。

<img src="../img/fig2.PNG"/>

### <font color="#5395ca">2.3 Merkle Trees</font>
Ralph Merkle 开发并描述了一种用于数字签名数据集并希望快速验证数据一致性的数据结构。他称之为 Merkle 树[32]。Merkle 树计算密码哈希，使得树中的每个节点都包含其子节点的哈希。树的叶子节点链接了编码数据集的值。自然地，使用非对称哈希以防止恢复原始值。

这种数据结构的目的是允许各方在不需要交换数据集本身的情况下验证数据集的一致性。在分布式环境中特别有用，因为由于数据集的大小，对物理数据进行分析是不切实际的。

Merkle 树，有时称为 Merkle 证明，通过提供一个唯一的哈希来防止数据被恶意或无意地修改，从而标识数据集。只有当另一个数据集计算出相同的哈希时，才能证明这两个数据集是相同的，否则它们是不同的。由于这个特性，在任何数据交换中，参与者可以轻松验证他们获得了他们期望的数据，或者在同步数据集时，参与者可以轻松验证他们最终获得了相同的结果。

由于每个数据子集也被哈希，如果参与者不需要处理完整的数据集，他们可以只交换子哈希。如果任何节点的值被篡改，从该节点到根节点的所有哈希都不匹配，并且无需遍历完整的数据集即可揭示此错误。

区块链平台本质上涉及不信任的分布式参与方，同时需要管理共享数据。在这种情况下，Merkle 树作为理想的解决方案，因为它们提供了哈希的有效性证明。此外，哈希值较小，因此非常适合在互联网上传输。

<img src="../img/Fig3.PNG"/>

图6中间的树展示了这个原则在一个二叉树上的应用。正如可以看到的那样，从下往上的每个节点都被哈希，通过一个名为𝑎𝑠ℎ的函数在抽象层面上可视化。叶子节点只对自身进行哈希，而所有其他父节点则对其子节点的递归哈希进行哈希。当需要在各方之间验证数据一致性时，可以验证任何节点的哈希。
Merkle树最初只包含哈希值，而数据集的值则存储在外部。这意味着树是建立在一个数据集之上的，这个数据集可以由任何其他的数据结构来建模。区块链和以太坊提出了一种结构，将所有的哈希和数据包装在一个树中。其描述将在下一节中给出。









































